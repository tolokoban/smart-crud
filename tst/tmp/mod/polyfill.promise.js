{"intl":"var _=function(){var D={\"en\":{},\"fr\":{}},X=require(\"$\").intl;function _(){return X(D,arguments);}_.all=D;return _}();\n","src":"/** @module polyfill.promise */require( 'polyfill.promise', function(require, module, exports) { var _=function(){var D={\"en\":{},\"fr\":{}},X=require(\"$\").intl;function _(){return X(D,arguments);}_.all=D;return _}();\n    /**\n * Polyfill for Promise...\n */\n/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   2.0.0\n */\n\nif (!window.Promise) {\n    (function() {\n        \"use strict\";\n\n        function $$utils$$objectOrFunction(x) {\n            return typeof x === 'function' || (typeof x === 'object' && x !== null);\n        }\n\n        function $$utils$$isFunction(x) {\n            return typeof x === 'function';\n        }\n\n        function $$utils$$isMaybeThenable(x) {\n            return typeof x === 'object' && x !== null;\n        }\n\n        var $$utils$$_isArray;\n\n        if (!Array.isArray) {\n            $$utils$$_isArray = function (x) {\n                return Object.prototype.toString.call(x) === '[object Array]';\n            };\n        } else {\n            $$utils$$_isArray = Array.isArray;\n        }\n\n        var $$utils$$isArray = $$utils$$_isArray;\n        var $$utils$$now = Date.now || function() { return new Date().getTime(); };\n        function $$utils$$F() { }\n\n        var $$utils$$o_create = (Object.create || function (o) {\n            if (arguments.length > 1) {\n                throw new Error('Second argument not supported');\n            }\n            if (typeof o !== 'object') {\n                throw new TypeError('Argument must be an object');\n            }\n            $$utils$$F.prototype = o;\n            return new $$utils$$F();\n        });\n\n        var $$asap$$len = 0;\n\n        var $$asap$$default = function asap(callback, arg) {\n            $$asap$$queue[$$asap$$len] = callback;\n            $$asap$$queue[$$asap$$len + 1] = arg;\n            $$asap$$len += 2;\n            if ($$asap$$len === 2) {\n                // If len is 1, that means that we need to schedule an async flush.\n                // If additional callbacks are queued before the queue is flushed, they\n                // will be processed by this flush that we are scheduling.\n                $$asap$$scheduleFlush();\n            }\n        };\n\n        var $$asap$$browserGlobal = (typeof window !== 'undefined') ? window : {};\n        var $$asap$$BrowserMutationObserver = $$asap$$browserGlobal.MutationObserver || $$asap$$browserGlobal.WebKitMutationObserver;\n\n        // test for web worker but not in IE10\n        var $$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n            typeof importScripts !== 'undefined' &&\n            typeof MessageChannel !== 'undefined';\n\n        // node\n        function $$asap$$useNextTick() {\n            return function() {\n                process.nextTick($$asap$$flush);\n            };\n        }\n\n        function $$asap$$useMutationObserver() {\n            var iterations = 0;\n            var observer = new $$asap$$BrowserMutationObserver($$asap$$flush);\n            var node = document.createTextNode('');\n            observer.observe(node, { characterData: true });\n\n            return function() {\n                node.data = (iterations = ++iterations % 2);\n            };\n        }\n\n        // web worker\n        function $$asap$$useMessageChannel() {\n            var channel = new MessageChannel();\n            channel.port1.onmessage = $$asap$$flush;\n            return function () {\n                channel.port2.postMessage(0);\n            };\n        }\n\n        function $$asap$$useSetTimeout() {\n            return function() {\n                setTimeout($$asap$$flush, 1);\n            };\n        }\n\n        var $$asap$$queue = new Array(1000);\n\n        function $$asap$$flush() {\n            for (var i = 0; i < $$asap$$len; i+=2) {\n                var callback = $$asap$$queue[i];\n                var arg = $$asap$$queue[i+1];\n\n                callback(arg);\n\n                $$asap$$queue[i] = undefined;\n                $$asap$$queue[i+1] = undefined;\n            }\n\n            $$asap$$len = 0;\n        }\n\n        var $$asap$$scheduleFlush;\n\n        // Decide what async method to use to triggering processing of queued callbacks:\n        if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n            $$asap$$scheduleFlush = $$asap$$useNextTick();\n        } else if ($$asap$$BrowserMutationObserver) {\n            $$asap$$scheduleFlush = $$asap$$useMutationObserver();\n        } else if ($$asap$$isWorker) {\n            $$asap$$scheduleFlush = $$asap$$useMessageChannel();\n        } else {\n            $$asap$$scheduleFlush = $$asap$$useSetTimeout();\n        }\n\n        function $$$internal$$noop() {}\n        var $$$internal$$PENDING   = void 0;\n        var $$$internal$$FULFILLED = 1;\n        var $$$internal$$REJECTED  = 2;\n        var $$$internal$$GET_THEN_ERROR = new $$$internal$$ErrorObject();\n\n        function $$$internal$$selfFullfillment() {\n            return new TypeError(\"You cannot resolve a promise with itself\");\n        }\n\n        function $$$internal$$cannotReturnOwn() {\n            return new TypeError('A promises callback cannot return that same promise.')\n        }\n\n        function $$$internal$$getThen(promise) {\n            try {\n                return promise.then;\n            } catch(error) {\n                $$$internal$$GET_THEN_ERROR.error = error;\n                return $$$internal$$GET_THEN_ERROR;\n            }\n        }\n\n        function $$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n            try {\n                then.call(value, fulfillmentHandler, rejectionHandler);\n            } catch(e) {\n                return e;\n            }\n        }\n\n        function $$$internal$$handleForeignThenable(promise, thenable, then) {\n            $$asap$$default(function(promise) {\n                var sealed = false;\n                var error = $$$internal$$tryThen(then, thenable, function(value) {\n                    if (sealed) { return; }\n                    sealed = true;\n                    if (thenable !== value) {\n                        $$$internal$$resolve(promise, value);\n                    } else {\n                        $$$internal$$fulfill(promise, value);\n                    }\n                }, function(reason) {\n                    if (sealed) { return; }\n                    sealed = true;\n\n                    $$$internal$$reject(promise, reason);\n                }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n                if (!sealed && error) {\n                    sealed = true;\n                    $$$internal$$reject(promise, error);\n                }\n            }, promise);\n        }\n\n        function $$$internal$$handleOwnThenable(promise, thenable) {\n            if (thenable._state === $$$internal$$FULFILLED) {\n                $$$internal$$fulfill(promise, thenable._result);\n            } else if (promise._state === $$$internal$$REJECTED) {\n                $$$internal$$reject(promise, thenable._result);\n            } else {\n                $$$internal$$subscribe(thenable, undefined, function(value) {\n                    $$$internal$$resolve(promise, value);\n                }, function(reason) {\n                    $$$internal$$reject(promise, reason);\n                });\n            }\n        }\n\n        function $$$internal$$handleMaybeThenable(promise, maybeThenable) {\n            if (maybeThenable.constructor === promise.constructor) {\n                $$$internal$$handleOwnThenable(promise, maybeThenable);\n            } else {\n                var then = $$$internal$$getThen(maybeThenable);\n\n                if (then === $$$internal$$GET_THEN_ERROR) {\n                    $$$internal$$reject(promise, $$$internal$$GET_THEN_ERROR.error);\n                } else if (then === undefined) {\n                    $$$internal$$fulfill(promise, maybeThenable);\n                } else if ($$utils$$isFunction(then)) {\n                    $$$internal$$handleForeignThenable(promise, maybeThenable, then);\n                } else {\n                    $$$internal$$fulfill(promise, maybeThenable);\n                }\n            }\n        }\n\n        function $$$internal$$resolve(promise, value) {\n            if (promise === value) {\n                $$$internal$$reject(promise, $$$internal$$selfFullfillment());\n            } else if ($$utils$$objectOrFunction(value)) {\n                $$$internal$$handleMaybeThenable(promise, value);\n            } else {\n                $$$internal$$fulfill(promise, value);\n            }\n        }\n\n        function $$$internal$$publishRejection(promise) {\n            if (promise._onerror) {\n                promise._onerror(promise._result);\n            }\n\n            $$$internal$$publish(promise);\n        }\n\n        function $$$internal$$fulfill(promise, value) {\n            if (promise._state !== $$$internal$$PENDING) { return; }\n\n            promise._result = value;\n            promise._state = $$$internal$$FULFILLED;\n\n            if (promise._subscribers.length === 0) {\n            } else {\n                $$asap$$default($$$internal$$publish, promise);\n            }\n        }\n\n        function $$$internal$$reject(promise, reason) {\n            if (promise._state !== $$$internal$$PENDING) { return; }\n            promise._state = $$$internal$$REJECTED;\n            promise._result = reason;\n\n            $$asap$$default($$$internal$$publishRejection, promise);\n        }\n\n        function $$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n            var subscribers = parent._subscribers;\n            var length = subscribers.length;\n\n            parent._onerror = null;\n\n            subscribers[length] = child;\n            subscribers[length + $$$internal$$FULFILLED] = onFulfillment;\n            subscribers[length + $$$internal$$REJECTED]  = onRejection;\n\n            if (length === 0 && parent._state) {\n                $$asap$$default($$$internal$$publish, parent);\n            }\n        }\n\n        function $$$internal$$publish(promise) {\n            var subscribers = promise._subscribers;\n            var settled = promise._state;\n\n            if (subscribers.length === 0) { return; }\n\n            var child, callback, detail = promise._result;\n\n            for (var i = 0; i < subscribers.length; i += 3) {\n                child = subscribers[i];\n                callback = subscribers[i + settled];\n\n                if (child) {\n                    $$$internal$$invokeCallback(settled, child, callback, detail);\n                } else {\n                    callback(detail);\n                }\n            }\n\n            promise._subscribers.length = 0;\n        }\n\n        function $$$internal$$ErrorObject() {\n            this.error = null;\n        }\n\n        var $$$internal$$TRY_CATCH_ERROR = new $$$internal$$ErrorObject();\n\n        function $$$internal$$tryCatch(callback, detail) {\n            try {\n                return callback(detail);\n            } catch(e) {\n                $$$internal$$TRY_CATCH_ERROR.error = e;\n                return $$$internal$$TRY_CATCH_ERROR;\n            }\n        }\n\n        function $$$internal$$invokeCallback(settled, promise, callback, detail) {\n            var hasCallback = $$utils$$isFunction(callback),\n            value, error, succeeded, failed;\n\n            if (hasCallback) {\n                value = $$$internal$$tryCatch(callback, detail);\n\n                if (value === $$$internal$$TRY_CATCH_ERROR) {\n                    failed = true;\n                    error = value.error;\n                    value = null;\n                } else {\n                    succeeded = true;\n                }\n\n                if (promise === value) {\n                    $$$internal$$reject(promise, $$$internal$$cannotReturnOwn());\n                    return;\n                }\n\n            } else {\n                value = detail;\n                succeeded = true;\n            }\n\n            if (promise._state !== $$$internal$$PENDING) {\n                // noop\n            } else if (hasCallback && succeeded) {\n                $$$internal$$resolve(promise, value);\n            } else if (failed) {\n                $$$internal$$reject(promise, error);\n            } else if (settled === $$$internal$$FULFILLED) {\n                $$$internal$$fulfill(promise, value);\n            } else if (settled === $$$internal$$REJECTED) {\n                $$$internal$$reject(promise, value);\n            }\n        }\n\n        function $$$internal$$initializePromise(promise, resolver) {\n            try {\n                resolver(function resolvePromise(value){\n                    $$$internal$$resolve(promise, value);\n                }, function rejectPromise(reason) {\n                    $$$internal$$reject(promise, reason);\n                });\n            } catch(e) {\n                $$$internal$$reject(promise, e);\n            }\n        }\n\n        function $$$enumerator$$makeSettledResult(state, position, value) {\n            if (state === $$$internal$$FULFILLED) {\n                return {\n                    state: 'fulfilled',\n                    value: value\n                };\n            } else {\n                return {\n                    state: 'rejected',\n                    reason: value\n                };\n            }\n        }\n\n        function $$$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {\n            this._instanceConstructor = Constructor;\n            this.promise = new Constructor($$$internal$$noop, label);\n            this._abortOnReject = abortOnReject;\n\n            if (this._validateInput(input)) {\n                this._input     = input;\n                this.length     = input.length;\n                this._remaining = input.length;\n\n                this._init();\n\n                if (this.length === 0) {\n                    $$$internal$$fulfill(this.promise, this._result);\n                } else {\n                    this.length = this.length || 0;\n                    this._enumerate();\n                    if (this._remaining === 0) {\n                        $$$internal$$fulfill(this.promise, this._result);\n                    }\n                }\n            } else {\n                $$$internal$$reject(this.promise, this._validationError());\n            }\n        }\n\n        $$$enumerator$$Enumerator.prototype._validateInput = function(input) {\n            return $$utils$$isArray(input);\n        };\n\n        $$$enumerator$$Enumerator.prototype._validationError = function() {\n            return new Error('Array Methods must be provided an Array');\n        };\n\n        $$$enumerator$$Enumerator.prototype._init = function() {\n            this._result = new Array(this.length);\n        };\n\n        var $$$enumerator$$default = $$$enumerator$$Enumerator;\n\n        $$$enumerator$$Enumerator.prototype._enumerate = function() {\n            var length  = this.length;\n            var promise = this.promise;\n            var input   = this._input;\n\n            for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\n                this._eachEntry(input[i], i);\n            }\n        };\n\n        $$$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n            var c = this._instanceConstructor;\n            if ($$utils$$isMaybeThenable(entry)) {\n                if (entry.constructor === c && entry._state !== $$$internal$$PENDING) {\n                    entry._onerror = null;\n                    this._settledAt(entry._state, i, entry._result);\n                } else {\n                    this._willSettleAt(c.resolve(entry), i);\n                }\n            } else {\n                this._remaining--;\n                this._result[i] = this._makeResult($$$internal$$FULFILLED, i, entry);\n            }\n        };\n\n        $$$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n            var promise = this.promise;\n\n            if (promise._state === $$$internal$$PENDING) {\n                this._remaining--;\n\n                if (this._abortOnReject && state === $$$internal$$REJECTED) {\n                    $$$internal$$reject(promise, value);\n                } else {\n                    this._result[i] = this._makeResult(state, i, value);\n                }\n            }\n\n            if (this._remaining === 0) {\n                $$$internal$$fulfill(promise, this._result);\n            }\n        };\n\n        $$$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {\n            return value;\n        };\n\n        $$$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n            var enumerator = this;\n\n            $$$internal$$subscribe(promise, undefined, function(value) {\n                enumerator._settledAt($$$internal$$FULFILLED, i, value);\n            }, function(reason) {\n                enumerator._settledAt($$$internal$$REJECTED, i, reason);\n            });\n        };\n\n        var $$promise$all$$default = function all(entries, label) {\n            return new $$$enumerator$$default(this, entries, true /* abort on reject */, label).promise;\n        };\n\n        var $$promise$race$$default = function race(entries, label) {\n            /*jshint validthis:true */\n            var Constructor = this;\n\n            var promise = new Constructor($$$internal$$noop, label);\n\n            if (!$$utils$$isArray(entries)) {\n                $$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n                return promise;\n            }\n\n            var length = entries.length;\n\n            function onFulfillment(value) {\n                $$$internal$$resolve(promise, value);\n            }\n\n            function onRejection(reason) {\n                $$$internal$$reject(promise, reason);\n            }\n\n            for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\n                $$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n            }\n\n            return promise;\n        };\n\n        var $$promise$resolve$$default = function resolve(object, label) {\n            /*jshint validthis:true */\n            var Constructor = this;\n\n            if (object && typeof object === 'object' && object.constructor === Constructor) {\n                return object;\n            }\n\n            var promise = new Constructor($$$internal$$noop, label);\n            $$$internal$$resolve(promise, object);\n            return promise;\n        };\n\n        var $$promise$reject$$default = function reject(reason, label) {\n            /*jshint validthis:true */\n            var Constructor = this;\n            var promise = new Constructor($$$internal$$noop, label);\n            $$$internal$$reject(promise, reason);\n            return promise;\n        };\n\n        var $$es6$promise$promise$$counter = 0;\n\n        function $$es6$promise$promise$$needsResolver() {\n            throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n        }\n\n        function $$es6$promise$promise$$needsNew() {\n            throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n        }\n\n        var $$es6$promise$promise$$default = $$es6$promise$promise$$Promise;\n\n        /**\n         Promise objects represent the eventual result of an asynchronous operation. The\n         primary way of interacting with a promise is through its `then` method, which\n         registers callbacks to receive either a promiseâ€™s eventual value or the reason\n         why the promise cannot be fulfilled.\n\n         Terminology\n         -----------\n\n         - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n         - `thenable` is an object or function that defines a `then` method.\n         - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n         - `exception` is a value that is thrown using the throw statement.\n         - `reason` is a value that indicates why a promise was rejected.\n         - `settled` the final resting state of a promise, fulfilled or rejected.\n\n         A promise can be in one of three states: pending, fulfilled, or rejected.\n\n         Promises that are fulfilled have a fulfillment value and are in the fulfilled\n         state.  Promises that are rejected have a rejection reason and are in the\n         rejected state.  A fulfillment value is never a thenable.\n\n         Promises can also be said to *resolve* a value.  If this value is also a\n         promise, then the original promise's settled state will match the value's\n         settled state.  So a promise that *resolves* a promise that rejects will\n         itself reject, and a promise that *resolves* a promise that fulfills will\n         itself fulfill.\n\n\n         Basic Usage:\n         ------------\n\n         ```js\n         var promise = new Promise(function(resolve, reject) {\n         // on success\n         resolve(value);\n\n         // on failure\n         reject(reason);\n         });\n\n         promise.then(function(value) {\n         // on fulfillment\n         }, function(reason) {\n         // on rejection\n         });\n         ```\n\n         Advanced Usage:\n         ---------------\n\n         Promises shine when abstracting away asynchronous interactions such as\n         `XMLHttpRequest`s.\n\n         ```js\n         function getJSON(url) {\n         return new Promise(function(resolve, reject){\n         var xhr = new XMLHttpRequest();\n\n         xhr.open('GET', url);\n         xhr.onreadystatechange = handler;\n         xhr.responseType = 'json';\n         xhr.setRequestHeader('Accept', 'application/json');\n         xhr.send();\n\n         function handler() {\n         if (this.readyState === this.DONE) {\n         if (this.status === 200) {\n         resolve(this.response);\n         } else {\n         reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n         }\n         }\n         };\n         });\n         }\n\n         getJSON('/posts.json').then(function(json) {\n         // on fulfillment\n         }, function(reason) {\n         // on rejection\n         });\n         ```\n\n         Unlike callbacks, promises are great composable primitives.\n\n         ```js\n         Promise.all([\n         getJSON('/posts'),\n         getJSON('/comments')\n         ]).then(function(values){\n         values[0] // => postsJSON\n         values[1] // => commentsJSON\n\n         return values;\n         });\n         ```\n\n         @class Promise\n         @param {function} resolver\n         @param {String} label optional string for labeling the promise.\n         Useful for tooling.\n         @constructor\n         */\n        function $$es6$promise$promise$$Promise(resolver, label) {\n            this._id = $$es6$promise$promise$$counter++;\n            this._label = label;\n            this._state = undefined;\n            this._result = undefined;\n            this._subscribers = [];\n\n            if ($$$internal$$noop !== resolver) {\n                if (!$$utils$$isFunction(resolver)) {\n                    $$es6$promise$promise$$needsResolver();\n                }\n\n                if (!(this instanceof $$es6$promise$promise$$Promise)) {\n                    $$es6$promise$promise$$needsNew();\n                }\n\n                $$$internal$$initializePromise(this, resolver);\n            }\n        }\n\n        $$es6$promise$promise$$Promise.all = $$promise$all$$default;\n        $$es6$promise$promise$$Promise.race = $$promise$race$$default;\n        $$es6$promise$promise$$Promise.resolve = $$promise$resolve$$default;\n        $$es6$promise$promise$$Promise.reject = $$promise$reject$$default;\n\n        $$es6$promise$promise$$Promise.prototype = {\n            constructor: $$es6$promise$promise$$Promise,\n\n            /**\n             The primary way of interacting with a promise is through its `then` method,\n             which registers callbacks to receive either a promise's eventual value or the\n             reason why the promise cannot be fulfilled.\n\n             ```js\n             findUser().then(function(user){\n             // user is available\n             }, function(reason){\n             // user is unavailable, and you are given the reason why\n             });\n             ```\n\n             Chaining\n             --------\n\n             The return value of `then` is itself a promise.  This second, 'downstream'\n             promise is resolved with the return value of the first promise's fulfillment\n             or rejection handler, or rejected if the handler throws an exception.\n\n             ```js\n             findUser().then(function (user) {\n             return user.name;\n             }, function (reason) {\n             return 'default name';\n             }).then(function (userName) {\n             // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n             // will be `'default name'`\n             });\n\n             findUser().then(function (user) {\n             throw new Error('Found user, but still unhappy');\n             }, function (reason) {\n             throw new Error('`findUser` rejected and we're unhappy');\n             }).then(function (value) {\n             // never reached\n             }, function (reason) {\n             // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n             // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n             });\n             ```\n             If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n             ```js\n             findUser().then(function (user) {\n             throw new PedagogicalException('Upstream error');\n             }).then(function (value) {\n             // never reached\n             }).then(function (value) {\n             // never reached\n             }, function (reason) {\n             // The `PedgagocialException` is propagated all the way down to here\n             });\n             ```\n\n             Assimilation\n             ------------\n\n             Sometimes the value you want to propagate to a downstream promise can only be\n             retrieved asynchronously. This can be achieved by returning a promise in the\n             fulfillment or rejection handler. The downstream promise will then be pending\n             until the returned promise is settled. This is called *assimilation*.\n\n             ```js\n             findUser().then(function (user) {\n             return findCommentsByAuthor(user);\n             }).then(function (comments) {\n             // The user's comments are now available\n             });\n             ```\n\n             If the assimliated promise rejects, then the downstream promise will also reject.\n\n             ```js\n             findUser().then(function (user) {\n             return findCommentsByAuthor(user);\n             }).then(function (comments) {\n             // If `findCommentsByAuthor` fulfills, we'll have the value here\n             }, function (reason) {\n             // If `findCommentsByAuthor` rejects, we'll have the reason here\n             });\n             ```\n\n             Simple Example\n             --------------\n\n             Synchronous Example\n\n             ```javascript\n             var result;\n\n             try {\n             result = findResult();\n             // success\n             } catch(reason) {\n             // failure\n             }\n             ```\n\n             Errback Example\n\n             ```js\n             findResult(function(result, err){\n             if (err) {\n             // failure\n             } else {\n             // success\n             }\n             });\n             ```\n\n             Promise Example;\n\n             ```javascript\n             findResult().then(function(result){\n             // success\n             }, function(reason){\n             // failure\n             });\n             ```\n\n             Advanced Example\n             --------------\n\n             Synchronous Example\n\n             ```javascript\n             var author, books;\n\n             try {\n             author = findAuthor();\n             books  = findBooksByAuthor(author);\n             // success\n             } catch(reason) {\n             // failure\n             }\n             ```\n\n             Errback Example\n\n             ```js\n\n             function foundBooks(books) {\n\n             }\n\n             function failure(reason) {\n\n             }\n\n             findAuthor(function(author, err){\n             if (err) {\n             failure(err);\n             // failure\n             } else {\n             try {\n             findBoooksByAuthor(author, function(books, err) {\n             if (err) {\n             failure(err);\n             } else {\n             try {\n             foundBooks(books);\n             } catch(reason) {\n             failure(reason);\n             }\n             }\n             });\n             } catch(error) {\n             failure(err);\n             }\n             // success\n             }\n             });\n             ```\n\n             Promise Example;\n\n             ```javascript\n             findAuthor().\n             then(findBooksByAuthor).\n             then(function(books){\n             // found books\n             }).catch(function(reason){\n             // something went wrong\n             });\n             ```\n\n             @method then\n             @param {Function} onFulfilled\n             @param {Function} onRejected\n             @param {String} label optional string for labeling the promise.\n             Useful for tooling.\n             @return {Promise}\n             */\n            then: function(onFulfillment, onRejection, label) {\n                var parent = this;\n                var state = parent._state;\n\n                if (state === $$$internal$$FULFILLED && !onFulfillment || state === $$$internal$$REJECTED && !onRejection) {\n                    return this;\n                }\n\n                parent._onerror = null;\n\n                var child = new this.constructor($$$internal$$noop, label);\n                var result = parent._result;\n\n                if (state) {\n                    var callback = arguments[state - 1];\n                    $$asap$$default(function(){\n                        $$$internal$$invokeCallback(state, child, callback, result);\n                    });\n                } else {\n                    $$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n                }\n\n                return child;\n            },\n\n            /**\n             `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n             as the catch block of a try/catch statement.\n\n             ```js\n             function findAuthor(){\n             throw new Error('couldn't find that author');\n             }\n\n             // synchronous\n             try {\n             findAuthor();\n             } catch(reason) {\n             // something went wrong\n             }\n\n             // async with promises\n             findAuthor().catch(function(reason){\n             // something went wrong\n             });\n             ```\n\n             @method catch\n             @param {Function} onRejection\n             @param {String} label optional string for labeling the promise.\n             Useful for tooling.\n             @return {Promise}\n             */\n            'catch': function(onRejection, label) {\n                return this.then(null, onRejection, label);\n            }\n        };\n\n        var $$es6$promise$polyfill$$default = function polyfill() {\n            var local;\n\n            if (typeof global !== 'undefined') {\n                local = global;\n            } else if (typeof window !== 'undefined' && window.document) {\n                local = window;\n            } else {\n                local = self;\n            }\n\n            var es6PromiseSupport =\n                \"Promise\" in local &&\n                // Some of these methods are missing from\n                // Firefox/Chrome experimental implementations\n                \"resolve\" in local.Promise &&\n                \"reject\" in local.Promise &&\n                \"all\" in local.Promise &&\n                \"race\" in local.Promise &&\n                // Older version of the spec had a resolver object\n                // as the arg rather than a function\n                (function() {\n                    var resolve;\n                    new local.Promise(function(r) { resolve = r; });\n                    return $$utils$$isFunction(resolve);\n                }());\n\n            if (!es6PromiseSupport) {\n                local.Promise = $$es6$promise$promise$$default;\n            }\n        };\n\n        var es6$promise$umd$$ES6Promise = {\n            Promise: $$es6$promise$promise$$default,\n            polyfill: $$es6$promise$polyfill$$default\n        };\n\n        // Calling polyfill.\n        $$es6$promise$polyfill$$default();\n\n        /* global define:true module:true window: true */\n/*\n        if (typeof define === 'function' && define['amd']) {\n            define(function() { return es6$promise$umd$$ES6Promise; });\n        } else if (typeof module !== 'undefined' && module['exports']) {\n            module['exports'] = es6$promise$umd$$ES6Promise;\n        } else if (typeof this !== 'undefined') {\n            this['ES6Promise'] = es6$promise$umd$$ES6Promise;\n        }\n*/\n    }).call(this);\n}\n\n\n  \nmodule.exports._ = _;\n/**\n * @module polyfill.promise\n * @see module:$\n\n */\n});","zip":"require(\"polyfill.promise\",function(t,n,e){var r=function(){function n(){return r(e,arguments)}var e={en:{},fr:{}},r=t(\"$\").intl;return n.all=e,n}();window.Promise||function(){\"use strict\";function t(t){return\"function\"==typeof t||\"object\"==typeof t&&null!==t}function n(t){return\"function\"==typeof t}function e(t){return\"object\"==typeof t&&null!==t}function r(){}function o(){for(var t=0;t<S;t+=2){(0,D[t])(D[t+1]),D[t]=void 0,D[t+1]=void 0}S=0}function i(){}function s(){return new TypeError(\"You cannot resolve a promise with itself\")}function u(){return new TypeError(\"A promises callback cannot return that same promise.\")}function c(t){try{return t.then}catch(t){return K.error=t,K}}function a(t,n,e,r){try{t.call(n,e,r)}catch(t){return t}}function f(t,n,e){C(function(t){var r=!1,o=a(e,n,function(e){r||(r=!0,n!==e?_(t,e):v(t,e))},function(n){r||(r=!0,d(t,n))},\"Settle: \"+(t._label||\" unknown promise\"));!r&&o&&(r=!0,d(t,o))},t)}function l(t,n){n._state===q?v(t,n._result):t._state===F?d(t,n._result):y(n,void 0,function(n){_(t,n)},function(n){d(t,n)})}function h(t,e){if(e.constructor===t.constructor)l(t,e);else{var r=c(e);r===K?d(t,K.error):void 0===r?v(t,e):n(r)?f(t,e,r):v(t,e)}}function _(n,e){n===e?d(n,s()):t(e)?h(n,e):v(n,e)}function p(t){t._onerror&&t._onerror(t._result),m(t)}function v(t,n){t._state===I&&(t._result=n,t._state=q,0===t._subscribers.length||C(m,t))}function d(t,n){t._state===I&&(t._state=F,t._result=n,C(p,t))}function y(t,n,e,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=n,o[i+q]=e,o[i+F]=r,0===i&&t._state&&C(m,t)}function m(t){var n=t._subscribers,e=t._state;if(0!==n.length){for(var r,o,i=t._result,s=0;s<n.length;s+=3)r=n[s],o=n[s+e],r?g(e,r,o,i):o(i);t._subscribers.length=0}}function w(){this.error=null}function b(t,n){try{return t(n)}catch(t){return N.error=t,N}}function g(t,e,r,o){var i,s,c,a,f=n(r);if(f){if(i=b(r,o),i===N?(a=!0,s=i.error,i=null):c=!0,e===i)return void d(e,u())}else i=o,c=!0;e._state!==I||(f&&c?_(e,i):a?d(e,s):t===q?v(e,i):t===F&&d(e,i))}function A(t,n){try{n(function(n){_(t,n)},function(n){d(t,n)})}catch(n){d(t,n)}}function j(t,n,e,r){this._instanceConstructor=t,this.promise=new t(i,r),this._abortOnReject=e,this._validateInput(n)?(this._input=n,this.length=n.length,this._remaining=n.length,this._init(),0===this.length?v(this.promise,this._result):(this.length=this.length||0,this._enumerate(),0===this._remaining&&v(this.promise,this._result))):d(this.promise,this._validationError())}function E(){throw new TypeError(\"You must pass a resolver function as the first argument to the promise constructor\")}function P(){throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\")}function T(t,e){this._id=G++,this._label=e,this._state=void 0,this._result=void 0,this._subscribers=[],i!==t&&(n(t)||E(),this instanceof T||P(),A(this,t))}var k;k=Array.isArray?Array.isArray:function(t){return\"[object Array]\"===Object.prototype.toString.call(t)};var M,O=k,S=(Date.now,Object.create,0),C=function(t,n){D[S]=t,D[S+1]=n,2===(S+=2)&&M()},R=\"undefined\"!=typeof window?window:{},x=R.MutationObserver||R.WebKitMutationObserver,Y=\"undefined\"!=typeof Uint8ClampedArray&&\"undefined\"!=typeof importScripts&&\"undefined\"!=typeof MessageChannel,D=new Array(1e3);M=\"undefined\"!=typeof process&&\"[object process]\"==={}.toString.call(process)?function(){return function(){process.nextTick(o)}}():x?function(){var t=0,n=new x(o),e=document.createTextNode(\"\");return n.observe(e,{characterData:!0}),function(){e.data=t=++t%2}}():Y?function(){var t=new MessageChannel;return t.port1.onmessage=o,function(){t.port2.postMessage(0)}}():function(){return function(){setTimeout(o,1)}}();var I=void 0,q=1,F=2,K=new w,N=new w;j.prototype._validateInput=function(t){return O(t)},j.prototype._validationError=function(){return new Error(\"Array Methods must be provided an Array\")},j.prototype._init=function(){this._result=new Array(this.length)};var U=j;j.prototype._enumerate=function(){for(var t=this.length,n=this.promise,e=this._input,r=0;n._state===I&&r<t;r++)this._eachEntry(e[r],r)},j.prototype._eachEntry=function(t,n){var r=this._instanceConstructor;e(t)?t.constructor===r&&t._state!==I?(t._onerror=null,this._settledAt(t._state,n,t._result)):this._willSettleAt(r.resolve(t),n):(this._remaining--,this._result[n]=this._makeResult(q,n,t))},j.prototype._settledAt=function(t,n,e){var r=this.promise;r._state===I&&(this._remaining--,this._abortOnReject&&t===F?d(r,e):this._result[n]=this._makeResult(t,n,e)),0===this._remaining&&v(r,this._result)},j.prototype._makeResult=function(t,n,e){return e},j.prototype._willSettleAt=function(t,n){var e=this;y(t,void 0,function(t){e._settledAt(q,n,t)},function(t){e._settledAt(F,n,t)})};var W=function(t,n){return new U(this,t,!0,n).promise},$=function(t,n){function e(t){_(s,t)}function r(t){d(s,t)}var o=this,s=new o(i,n);if(!O(t))return d(s,new TypeError(\"You must pass an array to race.\")),s;for(var u=t.length,c=0;s._state===I&&c<u;c++)y(o.resolve(t[c]),void 0,e,r);return s},z=function(t,n){var e=this;if(t&&\"object\"==typeof t&&t.constructor===e)return t;var r=new e(i,n);return _(r,t),r},B=function(t,n){var e=this,r=new e(i,n);return d(r,t),r},G=0,H=T;T.all=W,T.race=$,T.resolve=z,T.reject=B,T.prototype={constructor:T,then:function(t,n,e){var r=this,o=r._state;if(o===q&&!t||o===F&&!n)return this;r._onerror=null;var s=new this.constructor(i,e),u=r._result;if(o){var c=arguments[o-1];C(function(){g(o,s,c,u)})}else y(r,s,t,n);return s},catch:function(t,n){return this.then(null,t,n)}};var J=function(){var t;\"Promise\"in(t=\"undefined\"!=typeof global?global:\"undefined\"!=typeof window&&window.document?window:self)&&\"resolve\"in t.Promise&&\"reject\"in t.Promise&&\"all\"in t.Promise&&\"race\"in t.Promise&&function(){var e;return new t.Promise(function(t){e=t}),n(e)}()||(t.Promise=H)};J()}.call(this),n.exports._=r});\n//# sourceMappingURL=polyfill.promise.js.map","map":{"version":3,"file":"polyfill.promise.js","sources":["polyfill.promise.js"],"sourcesContent":["/** @module polyfill.promise */require( 'polyfill.promise', function(require, module, exports) { var _=function(){var D={\"en\":{},\"fr\":{}},X=require(\"$\").intl;function _(){return X(D,arguments);}_.all=D;return _}();\n    /**\n * Polyfill for Promise...\n */\n/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   2.0.0\n */\n\nif (!window.Promise) {\n    (function() {\n        \"use strict\";\n\n        function $$utils$$objectOrFunction(x) {\n            return typeof x === 'function' || (typeof x === 'object' && x !== null);\n        }\n\n        function $$utils$$isFunction(x) {\n            return typeof x === 'function';\n        }\n\n        function $$utils$$isMaybeThenable(x) {\n            return typeof x === 'object' && x !== null;\n        }\n\n        var $$utils$$_isArray;\n\n        if (!Array.isArray) {\n            $$utils$$_isArray = function (x) {\n                return Object.prototype.toString.call(x) === '[object Array]';\n            };\n        } else {\n            $$utils$$_isArray = Array.isArray;\n        }\n\n        var $$utils$$isArray = $$utils$$_isArray;\n        var $$utils$$now = Date.now || function() { return new Date().getTime(); };\n        function $$utils$$F() { }\n\n        var $$utils$$o_create = (Object.create || function (o) {\n            if (arguments.length > 1) {\n                throw new Error('Second argument not supported');\n            }\n            if (typeof o !== 'object') {\n                throw new TypeError('Argument must be an object');\n            }\n            $$utils$$F.prototype = o;\n            return new $$utils$$F();\n        });\n\n        var $$asap$$len = 0;\n\n        var $$asap$$default = function asap(callback, arg) {\n            $$asap$$queue[$$asap$$len] = callback;\n            $$asap$$queue[$$asap$$len + 1] = arg;\n            $$asap$$len += 2;\n            if ($$asap$$len === 2) {\n                // If len is 1, that means that we need to schedule an async flush.\n                // If additional callbacks are queued before the queue is flushed, they\n                // will be processed by this flush that we are scheduling.\n                $$asap$$scheduleFlush();\n            }\n        };\n\n        var $$asap$$browserGlobal = (typeof window !== 'undefined') ? window : {};\n        var $$asap$$BrowserMutationObserver = $$asap$$browserGlobal.MutationObserver || $$asap$$browserGlobal.WebKitMutationObserver;\n\n        // test for web worker but not in IE10\n        var $$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n            typeof importScripts !== 'undefined' &&\n            typeof MessageChannel !== 'undefined';\n\n        // node\n        function $$asap$$useNextTick() {\n            return function() {\n                process.nextTick($$asap$$flush);\n            };\n        }\n\n        function $$asap$$useMutationObserver() {\n            var iterations = 0;\n            var observer = new $$asap$$BrowserMutationObserver($$asap$$flush);\n            var node = document.createTextNode('');\n            observer.observe(node, { characterData: true });\n\n            return function() {\n                node.data = (iterations = ++iterations % 2);\n            };\n        }\n\n        // web worker\n        function $$asap$$useMessageChannel() {\n            var channel = new MessageChannel();\n            channel.port1.onmessage = $$asap$$flush;\n            return function () {\n                channel.port2.postMessage(0);\n            };\n        }\n\n        function $$asap$$useSetTimeout() {\n            return function() {\n                setTimeout($$asap$$flush, 1);\n            };\n        }\n\n        var $$asap$$queue = new Array(1000);\n\n        function $$asap$$flush() {\n            for (var i = 0; i < $$asap$$len; i+=2) {\n                var callback = $$asap$$queue[i];\n                var arg = $$asap$$queue[i+1];\n\n                callback(arg);\n\n                $$asap$$queue[i] = undefined;\n                $$asap$$queue[i+1] = undefined;\n            }\n\n            $$asap$$len = 0;\n        }\n\n        var $$asap$$scheduleFlush;\n\n        // Decide what async method to use to triggering processing of queued callbacks:\n        if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n            $$asap$$scheduleFlush = $$asap$$useNextTick();\n        } else if ($$asap$$BrowserMutationObserver) {\n            $$asap$$scheduleFlush = $$asap$$useMutationObserver();\n        } else if ($$asap$$isWorker) {\n            $$asap$$scheduleFlush = $$asap$$useMessageChannel();\n        } else {\n            $$asap$$scheduleFlush = $$asap$$useSetTimeout();\n        }\n\n        function $$$internal$$noop() {}\n        var $$$internal$$PENDING   = void 0;\n        var $$$internal$$FULFILLED = 1;\n        var $$$internal$$REJECTED  = 2;\n        var $$$internal$$GET_THEN_ERROR = new $$$internal$$ErrorObject();\n\n        function $$$internal$$selfFullfillment() {\n            return new TypeError(\"You cannot resolve a promise with itself\");\n        }\n\n        function $$$internal$$cannotReturnOwn() {\n            return new TypeError('A promises callback cannot return that same promise.')\n        }\n\n        function $$$internal$$getThen(promise) {\n            try {\n                return promise.then;\n            } catch(error) {\n                $$$internal$$GET_THEN_ERROR.error = error;\n                return $$$internal$$GET_THEN_ERROR;\n            }\n        }\n\n        function $$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n            try {\n                then.call(value, fulfillmentHandler, rejectionHandler);\n            } catch(e) {\n                return e;\n            }\n        }\n\n        function $$$internal$$handleForeignThenable(promise, thenable, then) {\n            $$asap$$default(function(promise) {\n                var sealed = false;\n                var error = $$$internal$$tryThen(then, thenable, function(value) {\n                    if (sealed) { return; }\n                    sealed = true;\n                    if (thenable !== value) {\n                        $$$internal$$resolve(promise, value);\n                    } else {\n                        $$$internal$$fulfill(promise, value);\n                    }\n                }, function(reason) {\n                    if (sealed) { return; }\n                    sealed = true;\n\n                    $$$internal$$reject(promise, reason);\n                }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n                if (!sealed && error) {\n                    sealed = true;\n                    $$$internal$$reject(promise, error);\n                }\n            }, promise);\n        }\n\n        function $$$internal$$handleOwnThenable(promise, thenable) {\n            if (thenable._state === $$$internal$$FULFILLED) {\n                $$$internal$$fulfill(promise, thenable._result);\n            } else if (promise._state === $$$internal$$REJECTED) {\n                $$$internal$$reject(promise, thenable._result);\n            } else {\n                $$$internal$$subscribe(thenable, undefined, function(value) {\n                    $$$internal$$resolve(promise, value);\n                }, function(reason) {\n                    $$$internal$$reject(promise, reason);\n                });\n            }\n        }\n\n        function $$$internal$$handleMaybeThenable(promise, maybeThenable) {\n            if (maybeThenable.constructor === promise.constructor) {\n                $$$internal$$handleOwnThenable(promise, maybeThenable);\n            } else {\n                var then = $$$internal$$getThen(maybeThenable);\n\n                if (then === $$$internal$$GET_THEN_ERROR) {\n                    $$$internal$$reject(promise, $$$internal$$GET_THEN_ERROR.error);\n                } else if (then === undefined) {\n                    $$$internal$$fulfill(promise, maybeThenable);\n                } else if ($$utils$$isFunction(then)) {\n                    $$$internal$$handleForeignThenable(promise, maybeThenable, then);\n                } else {\n                    $$$internal$$fulfill(promise, maybeThenable);\n                }\n            }\n        }\n\n        function $$$internal$$resolve(promise, value) {\n            if (promise === value) {\n                $$$internal$$reject(promise, $$$internal$$selfFullfillment());\n            } else if ($$utils$$objectOrFunction(value)) {\n                $$$internal$$handleMaybeThenable(promise, value);\n            } else {\n                $$$internal$$fulfill(promise, value);\n            }\n        }\n\n        function $$$internal$$publishRejection(promise) {\n            if (promise._onerror) {\n                promise._onerror(promise._result);\n            }\n\n            $$$internal$$publish(promise);\n        }\n\n        function $$$internal$$fulfill(promise, value) {\n            if (promise._state !== $$$internal$$PENDING) { return; }\n\n            promise._result = value;\n            promise._state = $$$internal$$FULFILLED;\n\n            if (promise._subscribers.length === 0) {\n            } else {\n                $$asap$$default($$$internal$$publish, promise);\n            }\n        }\n\n        function $$$internal$$reject(promise, reason) {\n            if (promise._state !== $$$internal$$PENDING) { return; }\n            promise._state = $$$internal$$REJECTED;\n            promise._result = reason;\n\n            $$asap$$default($$$internal$$publishRejection, promise);\n        }\n\n        function $$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n            var subscribers = parent._subscribers;\n            var length = subscribers.length;\n\n            parent._onerror = null;\n\n            subscribers[length] = child;\n            subscribers[length + $$$internal$$FULFILLED] = onFulfillment;\n            subscribers[length + $$$internal$$REJECTED]  = onRejection;\n\n            if (length === 0 && parent._state) {\n                $$asap$$default($$$internal$$publish, parent);\n            }\n        }\n\n        function $$$internal$$publish(promise) {\n            var subscribers = promise._subscribers;\n            var settled = promise._state;\n\n            if (subscribers.length === 0) { return; }\n\n            var child, callback, detail = promise._result;\n\n            for (var i = 0; i < subscribers.length; i += 3) {\n                child = subscribers[i];\n                callback = subscribers[i + settled];\n\n                if (child) {\n                    $$$internal$$invokeCallback(settled, child, callback, detail);\n                } else {\n                    callback(detail);\n                }\n            }\n\n            promise._subscribers.length = 0;\n        }\n\n        function $$$internal$$ErrorObject() {\n            this.error = null;\n        }\n\n        var $$$internal$$TRY_CATCH_ERROR = new $$$internal$$ErrorObject();\n\n        function $$$internal$$tryCatch(callback, detail) {\n            try {\n                return callback(detail);\n            } catch(e) {\n                $$$internal$$TRY_CATCH_ERROR.error = e;\n                return $$$internal$$TRY_CATCH_ERROR;\n            }\n        }\n\n        function $$$internal$$invokeCallback(settled, promise, callback, detail) {\n            var hasCallback = $$utils$$isFunction(callback),\n            value, error, succeeded, failed;\n\n            if (hasCallback) {\n                value = $$$internal$$tryCatch(callback, detail);\n\n                if (value === $$$internal$$TRY_CATCH_ERROR) {\n                    failed = true;\n                    error = value.error;\n                    value = null;\n                } else {\n                    succeeded = true;\n                }\n\n                if (promise === value) {\n                    $$$internal$$reject(promise, $$$internal$$cannotReturnOwn());\n                    return;\n                }\n\n            } else {\n                value = detail;\n                succeeded = true;\n            }\n\n            if (promise._state !== $$$internal$$PENDING) {\n                // noop\n            } else if (hasCallback && succeeded) {\n                $$$internal$$resolve(promise, value);\n            } else if (failed) {\n                $$$internal$$reject(promise, error);\n            } else if (settled === $$$internal$$FULFILLED) {\n                $$$internal$$fulfill(promise, value);\n            } else if (settled === $$$internal$$REJECTED) {\n                $$$internal$$reject(promise, value);\n            }\n        }\n\n        function $$$internal$$initializePromise(promise, resolver) {\n            try {\n                resolver(function resolvePromise(value){\n                    $$$internal$$resolve(promise, value);\n                }, function rejectPromise(reason) {\n                    $$$internal$$reject(promise, reason);\n                });\n            } catch(e) {\n                $$$internal$$reject(promise, e);\n            }\n        }\n\n        function $$$enumerator$$makeSettledResult(state, position, value) {\n            if (state === $$$internal$$FULFILLED) {\n                return {\n                    state: 'fulfilled',\n                    value: value\n                };\n            } else {\n                return {\n                    state: 'rejected',\n                    reason: value\n                };\n            }\n        }\n\n        function $$$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {\n            this._instanceConstructor = Constructor;\n            this.promise = new Constructor($$$internal$$noop, label);\n            this._abortOnReject = abortOnReject;\n\n            if (this._validateInput(input)) {\n                this._input     = input;\n                this.length     = input.length;\n                this._remaining = input.length;\n\n                this._init();\n\n                if (this.length === 0) {\n                    $$$internal$$fulfill(this.promise, this._result);\n                } else {\n                    this.length = this.length || 0;\n                    this._enumerate();\n                    if (this._remaining === 0) {\n                        $$$internal$$fulfill(this.promise, this._result);\n                    }\n                }\n            } else {\n                $$$internal$$reject(this.promise, this._validationError());\n            }\n        }\n\n        $$$enumerator$$Enumerator.prototype._validateInput = function(input) {\n            return $$utils$$isArray(input);\n        };\n\n        $$$enumerator$$Enumerator.prototype._validationError = function() {\n            return new Error('Array Methods must be provided an Array');\n        };\n\n        $$$enumerator$$Enumerator.prototype._init = function() {\n            this._result = new Array(this.length);\n        };\n\n        var $$$enumerator$$default = $$$enumerator$$Enumerator;\n\n        $$$enumerator$$Enumerator.prototype._enumerate = function() {\n            var length  = this.length;\n            var promise = this.promise;\n            var input   = this._input;\n\n            for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\n                this._eachEntry(input[i], i);\n            }\n        };\n\n        $$$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n            var c = this._instanceConstructor;\n            if ($$utils$$isMaybeThenable(entry)) {\n                if (entry.constructor === c && entry._state !== $$$internal$$PENDING) {\n                    entry._onerror = null;\n                    this._settledAt(entry._state, i, entry._result);\n                } else {\n                    this._willSettleAt(c.resolve(entry), i);\n                }\n            } else {\n                this._remaining--;\n                this._result[i] = this._makeResult($$$internal$$FULFILLED, i, entry);\n            }\n        };\n\n        $$$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n            var promise = this.promise;\n\n            if (promise._state === $$$internal$$PENDING) {\n                this._remaining--;\n\n                if (this._abortOnReject && state === $$$internal$$REJECTED) {\n                    $$$internal$$reject(promise, value);\n                } else {\n                    this._result[i] = this._makeResult(state, i, value);\n                }\n            }\n\n            if (this._remaining === 0) {\n                $$$internal$$fulfill(promise, this._result);\n            }\n        };\n\n        $$$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {\n            return value;\n        };\n\n        $$$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n            var enumerator = this;\n\n            $$$internal$$subscribe(promise, undefined, function(value) {\n                enumerator._settledAt($$$internal$$FULFILLED, i, value);\n            }, function(reason) {\n                enumerator._settledAt($$$internal$$REJECTED, i, reason);\n            });\n        };\n\n        var $$promise$all$$default = function all(entries, label) {\n            return new $$$enumerator$$default(this, entries, true /* abort on reject */, label).promise;\n        };\n\n        var $$promise$race$$default = function race(entries, label) {\n            /*jshint validthis:true */\n            var Constructor = this;\n\n            var promise = new Constructor($$$internal$$noop, label);\n\n            if (!$$utils$$isArray(entries)) {\n                $$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n                return promise;\n            }\n\n            var length = entries.length;\n\n            function onFulfillment(value) {\n                $$$internal$$resolve(promise, value);\n            }\n\n            function onRejection(reason) {\n                $$$internal$$reject(promise, reason);\n            }\n\n            for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\n                $$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n            }\n\n            return promise;\n        };\n\n        var $$promise$resolve$$default = function resolve(object, label) {\n            /*jshint validthis:true */\n            var Constructor = this;\n\n            if (object && typeof object === 'object' && object.constructor === Constructor) {\n                return object;\n            }\n\n            var promise = new Constructor($$$internal$$noop, label);\n            $$$internal$$resolve(promise, object);\n            return promise;\n        };\n\n        var $$promise$reject$$default = function reject(reason, label) {\n            /*jshint validthis:true */\n            var Constructor = this;\n            var promise = new Constructor($$$internal$$noop, label);\n            $$$internal$$reject(promise, reason);\n            return promise;\n        };\n\n        var $$es6$promise$promise$$counter = 0;\n\n        function $$es6$promise$promise$$needsResolver() {\n            throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n        }\n\n        function $$es6$promise$promise$$needsNew() {\n            throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n        }\n\n        var $$es6$promise$promise$$default = $$es6$promise$promise$$Promise;\n\n        /**\n         Promise objects represent the eventual result of an asynchronous operation. The\n         primary way of interacting with a promise is through its `then` method, which\n         registers callbacks to receive either a promiseâ€™s eventual value or the reason\n         why the promise cannot be fulfilled.\n\n         Terminology\n         -----------\n\n         - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n         - `thenable` is an object or function that defines a `then` method.\n         - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n         - `exception` is a value that is thrown using the throw statement.\n         - `reason` is a value that indicates why a promise was rejected.\n         - `settled` the final resting state of a promise, fulfilled or rejected.\n\n         A promise can be in one of three states: pending, fulfilled, or rejected.\n\n         Promises that are fulfilled have a fulfillment value and are in the fulfilled\n         state.  Promises that are rejected have a rejection reason and are in the\n         rejected state.  A fulfillment value is never a thenable.\n\n         Promises can also be said to *resolve* a value.  If this value is also a\n         promise, then the original promise's settled state will match the value's\n         settled state.  So a promise that *resolves* a promise that rejects will\n         itself reject, and a promise that *resolves* a promise that fulfills will\n         itself fulfill.\n\n\n         Basic Usage:\n         ------------\n\n         ```js\n         var promise = new Promise(function(resolve, reject) {\n         // on success\n         resolve(value);\n\n         // on failure\n         reject(reason);\n         });\n\n         promise.then(function(value) {\n         // on fulfillment\n         }, function(reason) {\n         // on rejection\n         });\n         ```\n\n         Advanced Usage:\n         ---------------\n\n         Promises shine when abstracting away asynchronous interactions such as\n         `XMLHttpRequest`s.\n\n         ```js\n         function getJSON(url) {\n         return new Promise(function(resolve, reject){\n         var xhr = new XMLHttpRequest();\n\n         xhr.open('GET', url);\n         xhr.onreadystatechange = handler;\n         xhr.responseType = 'json';\n         xhr.setRequestHeader('Accept', 'application/json');\n         xhr.send();\n\n         function handler() {\n         if (this.readyState === this.DONE) {\n         if (this.status === 200) {\n         resolve(this.response);\n         } else {\n         reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n         }\n         }\n         };\n         });\n         }\n\n         getJSON('/posts.json').then(function(json) {\n         // on fulfillment\n         }, function(reason) {\n         // on rejection\n         });\n         ```\n\n         Unlike callbacks, promises are great composable primitives.\n\n         ```js\n         Promise.all([\n         getJSON('/posts'),\n         getJSON('/comments')\n         ]).then(function(values){\n         values[0] // => postsJSON\n         values[1] // => commentsJSON\n\n         return values;\n         });\n         ```\n\n         @class Promise\n         @param {function} resolver\n         @param {String} label optional string for labeling the promise.\n         Useful for tooling.\n         @constructor\n         */\n        function $$es6$promise$promise$$Promise(resolver, label) {\n            this._id = $$es6$promise$promise$$counter++;\n            this._label = label;\n            this._state = undefined;\n            this._result = undefined;\n            this._subscribers = [];\n\n            if ($$$internal$$noop !== resolver) {\n                if (!$$utils$$isFunction(resolver)) {\n                    $$es6$promise$promise$$needsResolver();\n                }\n\n                if (!(this instanceof $$es6$promise$promise$$Promise)) {\n                    $$es6$promise$promise$$needsNew();\n                }\n\n                $$$internal$$initializePromise(this, resolver);\n            }\n        }\n\n        $$es6$promise$promise$$Promise.all = $$promise$all$$default;\n        $$es6$promise$promise$$Promise.race = $$promise$race$$default;\n        $$es6$promise$promise$$Promise.resolve = $$promise$resolve$$default;\n        $$es6$promise$promise$$Promise.reject = $$promise$reject$$default;\n\n        $$es6$promise$promise$$Promise.prototype = {\n            constructor: $$es6$promise$promise$$Promise,\n\n            /**\n             The primary way of interacting with a promise is through its `then` method,\n             which registers callbacks to receive either a promise's eventual value or the\n             reason why the promise cannot be fulfilled.\n\n             ```js\n             findUser().then(function(user){\n             // user is available\n             }, function(reason){\n             // user is unavailable, and you are given the reason why\n             });\n             ```\n\n             Chaining\n             --------\n\n             The return value of `then` is itself a promise.  This second, 'downstream'\n             promise is resolved with the return value of the first promise's fulfillment\n             or rejection handler, or rejected if the handler throws an exception.\n\n             ```js\n             findUser().then(function (user) {\n             return user.name;\n             }, function (reason) {\n             return 'default name';\n             }).then(function (userName) {\n             // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n             // will be `'default name'`\n             });\n\n             findUser().then(function (user) {\n             throw new Error('Found user, but still unhappy');\n             }, function (reason) {\n             throw new Error('`findUser` rejected and we're unhappy');\n             }).then(function (value) {\n             // never reached\n             }, function (reason) {\n             // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n             // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n             });\n             ```\n             If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n             ```js\n             findUser().then(function (user) {\n             throw new PedagogicalException('Upstream error');\n             }).then(function (value) {\n             // never reached\n             }).then(function (value) {\n             // never reached\n             }, function (reason) {\n             // The `PedgagocialException` is propagated all the way down to here\n             });\n             ```\n\n             Assimilation\n             ------------\n\n             Sometimes the value you want to propagate to a downstream promise can only be\n             retrieved asynchronously. This can be achieved by returning a promise in the\n             fulfillment or rejection handler. The downstream promise will then be pending\n             until the returned promise is settled. This is called *assimilation*.\n\n             ```js\n             findUser().then(function (user) {\n             return findCommentsByAuthor(user);\n             }).then(function (comments) {\n             // The user's comments are now available\n             });\n             ```\n\n             If the assimliated promise rejects, then the downstream promise will also reject.\n\n             ```js\n             findUser().then(function (user) {\n             return findCommentsByAuthor(user);\n             }).then(function (comments) {\n             // If `findCommentsByAuthor` fulfills, we'll have the value here\n             }, function (reason) {\n             // If `findCommentsByAuthor` rejects, we'll have the reason here\n             });\n             ```\n\n             Simple Example\n             --------------\n\n             Synchronous Example\n\n             ```javascript\n             var result;\n\n             try {\n             result = findResult();\n             // success\n             } catch(reason) {\n             // failure\n             }\n             ```\n\n             Errback Example\n\n             ```js\n             findResult(function(result, err){\n             if (err) {\n             // failure\n             } else {\n             // success\n             }\n             });\n             ```\n\n             Promise Example;\n\n             ```javascript\n             findResult().then(function(result){\n             // success\n             }, function(reason){\n             // failure\n             });\n             ```\n\n             Advanced Example\n             --------------\n\n             Synchronous Example\n\n             ```javascript\n             var author, books;\n\n             try {\n             author = findAuthor();\n             books  = findBooksByAuthor(author);\n             // success\n             } catch(reason) {\n             // failure\n             }\n             ```\n\n             Errback Example\n\n             ```js\n\n             function foundBooks(books) {\n\n             }\n\n             function failure(reason) {\n\n             }\n\n             findAuthor(function(author, err){\n             if (err) {\n             failure(err);\n             // failure\n             } else {\n             try {\n             findBoooksByAuthor(author, function(books, err) {\n             if (err) {\n             failure(err);\n             } else {\n             try {\n             foundBooks(books);\n             } catch(reason) {\n             failure(reason);\n             }\n             }\n             });\n             } catch(error) {\n             failure(err);\n             }\n             // success\n             }\n             });\n             ```\n\n             Promise Example;\n\n             ```javascript\n             findAuthor().\n             then(findBooksByAuthor).\n             then(function(books){\n             // found books\n             }).catch(function(reason){\n             // something went wrong\n             });\n             ```\n\n             @method then\n             @param {Function} onFulfilled\n             @param {Function} onRejected\n             @param {String} label optional string for labeling the promise.\n             Useful for tooling.\n             @return {Promise}\n             */\n            then: function(onFulfillment, onRejection, label) {\n                var parent = this;\n                var state = parent._state;\n\n                if (state === $$$internal$$FULFILLED && !onFulfillment || state === $$$internal$$REJECTED && !onRejection) {\n                    return this;\n                }\n\n                parent._onerror = null;\n\n                var child = new this.constructor($$$internal$$noop, label);\n                var result = parent._result;\n\n                if (state) {\n                    var callback = arguments[state - 1];\n                    $$asap$$default(function(){\n                        $$$internal$$invokeCallback(state, child, callback, result);\n                    });\n                } else {\n                    $$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n                }\n\n                return child;\n            },\n\n            /**\n             `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n             as the catch block of a try/catch statement.\n\n             ```js\n             function findAuthor(){\n             throw new Error('couldn't find that author');\n             }\n\n             // synchronous\n             try {\n             findAuthor();\n             } catch(reason) {\n             // something went wrong\n             }\n\n             // async with promises\n             findAuthor().catch(function(reason){\n             // something went wrong\n             });\n             ```\n\n             @method catch\n             @param {Function} onRejection\n             @param {String} label optional string for labeling the promise.\n             Useful for tooling.\n             @return {Promise}\n             */\n            'catch': function(onRejection, label) {\n                return this.then(null, onRejection, label);\n            }\n        };\n\n        var $$es6$promise$polyfill$$default = function polyfill() {\n            var local;\n\n            if (typeof global !== 'undefined') {\n                local = global;\n            } else if (typeof window !== 'undefined' && window.document) {\n                local = window;\n            } else {\n                local = self;\n            }\n\n            var es6PromiseSupport =\n                \"Promise\" in local &&\n                // Some of these methods are missing from\n                // Firefox/Chrome experimental implementations\n                \"resolve\" in local.Promise &&\n                \"reject\" in local.Promise &&\n                \"all\" in local.Promise &&\n                \"race\" in local.Promise &&\n                // Older version of the spec had a resolver object\n                // as the arg rather than a function\n                (function() {\n                    var resolve;\n                    new local.Promise(function(r) { resolve = r; });\n                    return $$utils$$isFunction(resolve);\n                }());\n\n            if (!es6PromiseSupport) {\n                local.Promise = $$es6$promise$promise$$default;\n            }\n        };\n\n        var es6$promise$umd$$ES6Promise = {\n            Promise: $$es6$promise$promise$$default,\n            polyfill: $$es6$promise$polyfill$$default\n        };\n\n        // Calling polyfill.\n        $$es6$promise$polyfill$$default();\n\n        /* global define:true module:true window: true */\n/*\n        if (typeof define === 'function' && define['amd']) {\n            define(function() { return es6$promise$umd$$ES6Promise; });\n        } else if (typeof module !== 'undefined' && module['exports']) {\n            module['exports'] = es6$promise$umd$$ES6Promise;\n        } else if (typeof this !== 'undefined') {\n            this['ES6Promise'] = es6$promise$umd$$ES6Promise;\n        }\n*/\n    }).call(this);\n}\n\n\n  \nmodule.exports._ = _;\n});"],"names":["require","module","exports","_","X","D","arguments","en","fr","intl","all","window","Promise","$$utils$$objectOrFunction","x","$$utils$$isFunction","$$utils$$isMaybeThenable","$$utils$$F","$$asap$$flush","i","$$asap$$len","callback","$$asap$$queue","undefined","$$$internal$$noop","$$$internal$$selfFullfillment","TypeError","$$$internal$$cannotReturnOwn","$$$internal$$getThen","promise","then","error","$$$internal$$GET_THEN_ERROR","$$$internal$$tryThen","value","fulfillmentHandler","rejectionHandler","call","e","$$$internal$$handleForeignThenable","thenable","$$asap$$default","sealed","$$$internal$$resolve","$$$internal$$fulfill","reason","$$$internal$$reject","_label","$$$internal$$handleOwnThenable","_state","$$$internal$$FULFILLED","_result","$$$internal$$REJECTED","$$$internal$$subscribe","$$$internal$$handleMaybeThenable","maybeThenable","constructor","$$$internal$$publishRejection","_onerror","$$$internal$$publish","$$$internal$$PENDING","_subscribers","length","parent","child","onFulfillment","onRejection","subscribers","settled","detail","$$$internal$$invokeCallback","$$$internal$$ErrorObject","this","$$$internal$$tryCatch","$$$internal$$TRY_CATCH_ERROR","succeeded","failed","hasCallback","$$$internal$$initializePromise","resolver","$$$enumerator$$Enumerator","Constructor","input","abortOnReject","label","_instanceConstructor","_abortOnReject","_validateInput","_input","_remaining","_init","_enumerate","_validationError","$$es6$promise$promise$$needsResolver","$$es6$promise$promise$$needsNew","$$es6$promise$promise$$Promise","_id","$$es6$promise$promise$$counter","$$utils$$_isArray","Array","isArray","Object","prototype","toString","$$asap$$scheduleFlush","$$utils$$isArray","Date","now","create","arg","$$asap$$browserGlobal","$$asap$$BrowserMutationObserver","MutationObserver","WebKitMutationObserver","$$asap$$isWorker","Uint8ClampedArray","importScripts","MessageChannel","process","nextTick","iterations","observer","node","document","createTextNode","observe","characterData","data","channel","port1","onmessage","port2","postMessage","setTimeout","Error","$$$enumerator$$default","_eachEntry","entry","c","_settledAt","_willSettleAt","resolve","_makeResult","state","enumerator","$$promise$all$$default","entries","$$promise$race$$default","$$promise$resolve$$default","object","$$promise$reject$$default","$$es6$promise$promise$$default","race","reject","result","catch","$$es6$promise$polyfill$$default","local","global","self","r"],"mappings":"AAA+BA,QAAS,mBAAoB,SAASA,EAASC,EAAQC,GAAW,GAAIC,GAAE,WAAuD,QAASA,KAAI,MAAOC,GAAEC,EAAEC,WAApE,GAAID,IAAGE,MAAQC,OAASJ,EAAEJ,EAAQ,KAAKS,IAAiD,OAARN,GAAEO,IAAIL,EAASF,IAY5MQ,QAAOC,SACR,WACI,YAEA,SAASC,GAA0BC,GAC/B,MAAoB,kBAANA,IAAkC,gBAANA,IAAwB,OAANA,EAGhE,QAASC,GAAoBD,GACzB,MAAoB,kBAANA,GAGlB,QAASE,GAAyBF,GAC9B,MAAoB,gBAANA,IAAwB,OAANA,EAepC,QAASG,MAsET,QAASC,KACL,IAAK,GAAIC,GAAI,EAAGA,EAAIC,EAAaD,GAAG,EAAG,EAInCE,EAHeC,EAAcH,IACnBG,EAAcH,EAAE,IAI1BG,EAAcH,OAAKI,GACnBD,EAAcH,EAAE,OAAKI,GAGzBH,EAAc,EAgBlB,QAASI,MAMT,QAASC,KACL,MAAO,IAAIC,WAAU,4CAGzB,QAASC,KACL,MAAO,IAAID,WAAU,wDAGzB,QAASE,GAAqBC,GAC1B,IACI,MAAOA,GAAQC,KACjB,MAAMC,GAEJ,MADAC,GAA4BD,MAAQA,EAC7BC,GAIf,QAASC,GAAqBH,EAAMI,EAAOC,EAAoBC,GAC3D,IACIN,EAAKO,KAAKH,EAAOC,EAAoBC,GACvC,MAAME,GACJ,MAAOA,IAIf,QAASC,GAAmCV,EAASW,EAAUV,GAC3DW,EAAgB,SAASZ,GACrB,GAAIa,IAAS,EACTX,EAAQE,EAAqBH,EAAMU,EAAU,SAASN,GAClDQ,IACJA,GAAS,EACLF,IAAaN,EACbS,EAAqBd,EAASK,GAE9BU,EAAqBf,EAASK,KAEnC,SAASW,GACJH,IACJA,GAAS,EAETI,EAAoBjB,EAASgB,KAC9B,YAAchB,EAAQkB,QAAU,sBAE9BL,GAAUX,IACXW,GAAS,EACTI,EAAoBjB,EAASE,KAElCF,GAGP,QAASmB,GAA+BnB,EAASW,GACzCA,EAASS,SAAWC,EACpBN,EAAqBf,EAASW,EAASW,SAChCtB,EAAQoB,SAAWG,EAC1BN,EAAoBjB,EAASW,EAASW,SAEtCE,EAAuBb,MAAUjB,GAAW,SAASW,GACjDS,EAAqBd,EAASK,IAC/B,SAASW,GACRC,EAAoBjB,EAASgB,KAKzC,QAASS,GAAiCzB,EAAS0B,GAC/C,GAAIA,EAAcC,cAAgB3B,EAAQ2B,YACtCR,EAA+BnB,EAAS0B,OACrC,CACH,GAAIzB,GAAOF,EAAqB2B,EAE5BzB,KAASE,EACTc,EAAoBjB,EAASG,EAA4BD,WACzCR,KAATO,EACPc,EAAqBf,EAAS0B,GACvBxC,EAAoBe,GAC3BS,EAAmCV,EAAS0B,EAAezB,GAE3Dc,EAAqBf,EAAS0B,IAK1C,QAASZ,GAAqBd,EAASK,GAC/BL,IAAYK,EACZY,EAAoBjB,EAASJ,KACtBZ,EAA0BqB,GACjCoB,EAAiCzB,EAASK,GAE1CU,EAAqBf,EAASK,GAItC,QAASuB,GAA8B5B,GAC/BA,EAAQ6B,UACR7B,EAAQ6B,SAAS7B,EAAQsB,SAG7BQ,EAAqB9B,GAGzB,QAASe,GAAqBf,EAASK,GAC/BL,EAAQoB,SAAWW,IAEvB/B,EAAQsB,QAAUjB,EAClBL,EAAQoB,OAASC,EAEmB,IAAhCrB,EAAQgC,aAAaC,QAErBrB,EAAgBkB,EAAsB9B,IAI9C,QAASiB,GAAoBjB,EAASgB,GAC9BhB,EAAQoB,SAAWW,IACvB/B,EAAQoB,OAASG,EACjBvB,EAAQsB,QAAUN,EAElBJ,EAAgBgB,EAA+B5B,IAGnD,QAASwB,GAAuBU,EAAQC,EAAOC,EAAeC,GAC1D,GAAIC,GAAcJ,EAAOF,aACrBC,EAASK,EAAYL,MAEzBC,GAAOL,SAAW,KAElBS,EAAYL,GAAUE,EACtBG,EAAYL,EAASZ,GAA0Be,EAC/CE,EAAYL,EAASV,GAA0Bc,EAEhC,IAAXJ,GAAgBC,EAAOd,QACvBR,EAAgBkB,EAAsBI,GAI9C,QAASJ,GAAqB9B,GAC1B,GAAIsC,GAActC,EAAQgC,aACtBO,EAAUvC,EAAQoB,MAEtB,IAA2B,IAAvBkB,EAAYL,OAAhB,CAIA,IAAK,GAFDE,GAAO3C,EAAUgD,EAASxC,EAAQsB,QAE7BhC,EAAI,EAAGA,EAAIgD,EAAYL,OAAQ3C,GAAK,EACzC6C,EAAQG,EAAYhD,GACpBE,EAAW8C,EAAYhD,EAAIiD,GAEvBJ,EACAM,EAA4BF,EAASJ,EAAO3C,EAAUgD,GAEtDhD,EAASgD,EAIjBxC,GAAQgC,aAAaC,OAAS,GAGlC,QAASS,KACLC,KAAKzC,MAAQ,KAKjB,QAAS0C,GAAsBpD,EAAUgD,GACrC,IACI,MAAOhD,GAASgD,GAClB,MAAM/B,GAEJ,MADAoC,GAA6B3C,MAAQO,EAC9BoC,GAIf,QAASJ,GAA4BF,EAASvC,EAASR,EAAUgD,GAC7D,GACAnC,GAAOH,EAAO4C,EAAWC,EADrBC,EAAc9D,EAAoBM,EAGtC,IAAIwD,GAWA,GAVA3C,EAAQuC,EAAsBpD,EAAUgD,GAEpCnC,IAAUwC,GACVE,GAAS,EACT7C,EAAQG,EAAMH,MACdG,EAAQ,MAERyC,GAAY,EAGZ9C,IAAYK,EAEZ,WADAY,GAAoBjB,EAASF,SAKjCO,GAAQmC,EACRM,GAAY,CAGZ9C,GAAQoB,SAAWW,IAEZiB,GAAeF,EACtBhC,EAAqBd,EAASK,GACvB0C,EACP9B,EAAoBjB,EAASE,GACtBqC,IAAYlB,EACnBN,EAAqBf,EAASK,GACvBkC,IAAYhB,GACnBN,EAAoBjB,EAASK,IAIrC,QAAS4C,GAA+BjD,EAASkD,GAC7C,IACIA,EAAS,SAAwB7C,GAC7BS,EAAqBd,EAASK,IAC/B,SAAuBW,GACtBC,EAAoBjB,EAASgB,KAEnC,MAAMP,GACJQ,EAAoBjB,EAASS,IAkBrC,QAAS0C,GAA0BC,EAAaC,EAAOC,EAAeC,GAClEZ,KAAKa,qBAAuBJ,EAC5BT,KAAK3C,QAAU,GAAIoD,GAAYzD,EAAmB4D,GAClDZ,KAAKc,eAAiBH,EAElBX,KAAKe,eAAeL,IACpBV,KAAKgB,OAAaN,EAClBV,KAAKV,OAAaoB,EAAMpB,OACxBU,KAAKiB,WAAaP,EAAMpB,OAExBU,KAAKkB,QAEe,IAAhBlB,KAAKV,OACLlB,EAAqB4B,KAAK3C,QAAS2C,KAAKrB,UAExCqB,KAAKV,OAASU,KAAKV,QAAU,EAC7BU,KAAKmB,aACmB,IAApBnB,KAAKiB,YACL7C,EAAqB4B,KAAK3C,QAAS2C,KAAKrB,WAIhDL,EAAoB0B,KAAK3C,QAAS2C,KAAKoB,oBAkI/C,QAASC,KACL,KAAM,IAAInE,WAAU,sFAGxB,QAASoE,KACL,KAAM,IAAIpE,WAAU,yHA6GxB,QAASqE,GAA+BhB,EAAUK,GAC9CZ,KAAKwB,IAAMC,IACXzB,KAAKzB,OAASqC,EACdZ,KAAKvB,WAAS1B,GACdiD,KAAKrB,YAAU5B,GACfiD,KAAKX,gBAEDrC,IAAsBuD,IACjBhE,EAAoBgE,IACrBc,IAGErB,eAAgBuB,IAClBD,IAGJhB,EAA+BN,KAAMO,IAznB7C,GAAImB,EAOAA,GALCC,MAAMC,QAKaD,MAAMC,QAJN,SAAUtF,GAC1B,MAA6C,mBAAtCuF,OAAOC,UAAUC,SAASlE,KAAKvB,GAM9C,IAsFI0F,GAtFAC,EAAmBP,EAenB9E,GAdesF,KAAKC,IAGCN,OAAOO,OAWd,GAEdnE,EAAkB,SAAcpB,EAAUwF,GAC1CvF,EAAcF,GAAeC,EAC7BC,EAAcF,EAAc,GAAKyF,EAEb,KADpBzF,GAAe,IAKXoF,KAIJM,EAA2C,mBAAXnG,QAA0BA,UAC1DoG,EAAkCD,EAAsBE,kBAAoBF,EAAsBG,uBAGlGC,EAAgD,mBAAtBC,oBACD,mBAAlBC,gBACmB,mBAAnBC,gBAmCP/F,EAAgB,GAAI6E,OAAM,IAoB1BK,GADmB,mBAAZc,UAAyD,wBAA3Bf,SAASlE,KAAKiF,SAnDvD,WACI,MAAO,YACHA,QAAQC,SAASrG,OAmDd6F,EA/CX,WACI,GAAIS,GAAa,EACbC,EAAW,GAAIV,GAAgC7F,GAC/CwG,EAAOC,SAASC,eAAe,GAGnC,OAFAH,GAASI,QAAQH,GAAQI,eAAe,IAEjC,WACHJ,EAAKK,KAAQP,IAAeA,EAAa,MA0CtCN,EArCX,WACI,GAAIc,GAAU,GAAIX,eAElB,OADAW,GAAQC,MAAMC,UAAYhH,EACnB,WACH8G,EAAQG,MAAMC,YAAY,OAIlC,WACI,MAAO,YACHC,WAAWnH,EAAe,MAkClC,IAAI0C,OAAyB,GACzBV,EAAyB,EACzBE,EAAyB,EACzBpB,EAA8B,GAAIuC,GAmKlCG,EAA+B,GAAIH,EAqGvCS,GAA0BsB,UAAUf,eAAiB,SAASL,GAC1D,MAAOuB,GAAiBvB,IAG5BF,EAA0BsB,UAAUV,iBAAmB,WACnD,MAAO,IAAI0C,OAAM,4CAGrBtD,EAA0BsB,UAAUZ,MAAQ,WACxClB,KAAKrB,QAAU,GAAIgD,OAAM3B,KAAKV,QAGlC,IAAIyE,GAAyBvD,CAE7BA,GAA0BsB,UAAUX,WAAa,WAK7C,IAAK,GAJD7B,GAAUU,KAAKV,OACfjC,EAAU2C,KAAK3C,QACfqD,EAAUV,KAAKgB,OAEVrE,EAAI,EAAGU,EAAQoB,SAAWW,GAAwBzC,EAAI2C,EAAQ3C,IACnEqD,KAAKgE,WAAWtD,EAAM/D,GAAIA,IAIlC6D,EAA0BsB,UAAUkC,WAAa,SAASC,EAAOtH,GAC7D,GAAIuH,GAAIlE,KAAKa,oBACTrE,GAAyByH,GACrBA,EAAMjF,cAAgBkF,GAAKD,EAAMxF,SAAWW,GAC5C6E,EAAM/E,SAAW,KACjBc,KAAKmE,WAAWF,EAAMxF,OAAQ9B,EAAGsH,EAAMtF,UAEvCqB,KAAKoE,cAAcF,EAAEG,QAAQJ,GAAQtH,IAGzCqD,KAAKiB,aACLjB,KAAKrB,QAAQhC,GAAKqD,KAAKsE,YAAY5F,EAAwB/B,EAAGsH,KAItEzD,EAA0BsB,UAAUqC,WAAa,SAASI,EAAO5H,EAAGe,GAChE,GAAIL,GAAU2C,KAAK3C,OAEfA,GAAQoB,SAAWW,IACnBY,KAAKiB,aAEDjB,KAAKc,gBAAkByD,IAAU3F,EACjCN,EAAoBjB,EAASK,GAE7BsC,KAAKrB,QAAQhC,GAAKqD,KAAKsE,YAAYC,EAAO5H,EAAGe,IAI7B,IAApBsC,KAAKiB,YACL7C,EAAqBf,EAAS2C,KAAKrB,UAI3C6B,EAA0BsB,UAAUwC,YAAc,SAASC,EAAO5H,EAAGe,GACjE,MAAOA,IAGX8C,EAA0BsB,UAAUsC,cAAgB,SAAS/G,EAASV,GAClE,GAAI6H,GAAaxE,IAEjBnB,GAAuBxB,MAASN,GAAW,SAASW,GAChD8G,EAAWL,WAAWzF,EAAwB/B,EAAGe,IAClD,SAASW,GACRmG,EAAWL,WAAWvF,EAAuBjC,EAAG0B,KAIxD,IAAIoG,GAAyB,SAAaC,EAAS9D,GAC/C,MAAO,IAAImD,GAAuB/D,KAAM0E,GAAS,EAA4B9D,GAAOvD,SAGpFsH,EAA0B,SAAcD,EAAS9D,GAajD,QAASnB,GAAc/B,GACnBS,EAAqBd,EAASK,GAGlC,QAASgC,GAAYrB,GACjBC,EAAoBjB,EAASgB,GAhBjC,GAAIoC,GAAcT,KAEd3C,EAAU,GAAIoD,GAAYzD,EAAmB4D,EAEjD,KAAKqB,EAAiByC,GAElB,MADApG,GAAoBjB,EAAS,GAAIH,WAAU,oCACpCG,CAaX,KAAK,GAVDiC,GAASoF,EAAQpF,OAUZ3C,EAAI,EAAGU,EAAQoB,SAAWW,GAAwBzC,EAAI2C,EAAQ3C,IACnEkC,EAAuB4B,EAAY4D,QAAQK,EAAQ/H,QAAKI,GAAW0C,EAAeC,EAGtF,OAAOrC,IAGPuH,EAA6B,SAAiBC,EAAQjE,GAEtD,GAAIH,GAAcT,IAElB,IAAI6E,GAA4B,gBAAXA,IAAuBA,EAAO7F,cAAgByB,EAC/D,MAAOoE,EAGX,IAAIxH,GAAU,GAAIoD,GAAYzD,EAAmB4D,EAEjD,OADAzC,GAAqBd,EAASwH,GACvBxH,GAGPyH,EAA4B,SAAgBzG,EAAQuC,GAEpD,GAAIH,GAAcT,KACd3C,EAAU,GAAIoD,GAAYzD,EAAmB4D,EAEjD,OADAtC,GAAoBjB,EAASgB,GACtBhB,GAGPoE,EAAiC,EAUjCsD,EAAiCxD,CA8HrCA,GAA+BrF,IAAMuI,EACrClD,EAA+ByD,KAAOL,EACtCpD,EAA+B8C,QAAUO,EACzCrD,EAA+B0D,OAASH,EAExCvD,EAA+BO,WAC3B9C,YAAauC,EAoMbjE,KAAM,SAASmC,EAAeC,EAAakB,GACvC,GAAIrB,GAASS,KACTuE,EAAQhF,EAAOd,MAEnB,IAAI8F,IAAU7F,IAA2Be,GAAiB8E,IAAU3F,IAA0Bc,EAC1F,MAAOM,KAGXT,GAAOL,SAAW,IAElB,IAAIM,GAAQ,GAAIQ,MAAKhB,YAAYhC,EAAmB4D,GAChDsE,EAAS3F,EAAOZ,OAEpB,IAAI4F,EAAO,CACP,GAAI1H,GAAWf,UAAUyI,EAAQ,EACjCtG,GAAgB,WACZ6B,EAA4ByE,EAAO/E,EAAO3C,EAAUqI,SAGxDrG,GAAuBU,EAAQC,EAAOC,EAAeC,EAGzD,OAAOF,IA+BX2F,MAAS,SAASzF,EAAakB,GAC3B,MAAOZ,MAAK1C,KAAK,KAAMoC,EAAakB,IAI5C,IAAIwE,GAAkC,WAClC,GAAIC,EAWA,aARAA,EADkB,mBAAXC,QACCA,OACiB,mBAAXnJ,SAA0BA,OAAOgH,SACvChH,OAEAoJ,OAOR,WAAaF,GAAMjJ,SACnB,UAAYiJ,GAAMjJ,SAClB,OAASiJ,GAAMjJ,SACf,QAAUiJ,GAAMjJ,SAGf,WACG,GAAIiI,EAEJ,OADA,IAAIgB,GAAMjJ,QAAQ,SAASoJ,GAAKnB,EAAUmB,IACnCjJ,EAAoB8H,QAI/BgB,EAAMjJ,QAAU2I,GAUxBK,MAYDvH,KAAKmC,MAKZvE,EAAOC,QAAQC,EAAIA"},"dependencies":["mod/$"]}