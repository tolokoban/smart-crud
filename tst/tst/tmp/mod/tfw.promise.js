{"intl":"","src":"require( 'tfw.promise', function(exports, module) {  /**\n * Polyfill for Promise...\n */\n/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   2.0.0\n */\n\nif (!window.Promise) {\n    (function() {\n        \"use strict\";\n\n        function $$utils$$objectOrFunction(x) {\n            return typeof x === 'function' || (typeof x === 'object' && x !== null);\n        }\n\n        function $$utils$$isFunction(x) {\n            return typeof x === 'function';\n        }\n\n        function $$utils$$isMaybeThenable(x) {\n            return typeof x === 'object' && x !== null;\n        }\n\n        var $$utils$$_isArray;\n\n        if (!Array.isArray) {\n            $$utils$$_isArray = function (x) {\n                return Object.prototype.toString.call(x) === '[object Array]';\n            };\n        } else {\n            $$utils$$_isArray = Array.isArray;\n        }\n\n        var $$utils$$isArray = $$utils$$_isArray;\n        var $$utils$$now = Date.now || function() { return new Date().getTime(); };\n        function $$utils$$F() { }\n\n        var $$utils$$o_create = (Object.create || function (o) {\n            if (arguments.length > 1) {\n                throw new Error('Second argument not supported');\n            }\n            if (typeof o !== 'object') {\n                throw new TypeError('Argument must be an object');\n            }\n            $$utils$$F.prototype = o;\n            return new $$utils$$F();\n        });\n\n        var $$asap$$len = 0;\n\n        var $$asap$$default = function asap(callback, arg) {\n            $$asap$$queue[$$asap$$len] = callback;\n            $$asap$$queue[$$asap$$len + 1] = arg;\n            $$asap$$len += 2;\n            if ($$asap$$len === 2) {\n                // If len is 1, that means that we need to schedule an async flush.\n                // If additional callbacks are queued before the queue is flushed, they\n                // will be processed by this flush that we are scheduling.\n                $$asap$$scheduleFlush();\n            }\n        };\n\n        var $$asap$$browserGlobal = (typeof window !== 'undefined') ? window : {};\n        var $$asap$$BrowserMutationObserver = $$asap$$browserGlobal.MutationObserver || $$asap$$browserGlobal.WebKitMutationObserver;\n\n        // test for web worker but not in IE10\n        var $$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n            typeof importScripts !== 'undefined' &&\n            typeof MessageChannel !== 'undefined';\n\n        // node\n        function $$asap$$useNextTick() {\n            return function() {\n                process.nextTick($$asap$$flush);\n            };\n        }\n\n        function $$asap$$useMutationObserver() {\n            var iterations = 0;\n            var observer = new $$asap$$BrowserMutationObserver($$asap$$flush);\n            var node = document.createTextNode('');\n            observer.observe(node, { characterData: true });\n\n            return function() {\n                node.data = (iterations = ++iterations % 2);\n            };\n        }\n\n        // web worker\n        function $$asap$$useMessageChannel() {\n            var channel = new MessageChannel();\n            channel.port1.onmessage = $$asap$$flush;\n            return function () {\n                channel.port2.postMessage(0);\n            };\n        }\n\n        function $$asap$$useSetTimeout() {\n            return function() {\n                setTimeout($$asap$$flush, 1);\n            };\n        }\n\n        var $$asap$$queue = new Array(1000);\n\n        function $$asap$$flush() {\n            for (var i = 0; i < $$asap$$len; i+=2) {\n                var callback = $$asap$$queue[i];\n                var arg = $$asap$$queue[i+1];\n\n                callback(arg);\n\n                $$asap$$queue[i] = undefined;\n                $$asap$$queue[i+1] = undefined;\n            }\n\n            $$asap$$len = 0;\n        }\n\n        var $$asap$$scheduleFlush;\n\n        // Decide what async method to use to triggering processing of queued callbacks:\n        if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n            $$asap$$scheduleFlush = $$asap$$useNextTick();\n        } else if ($$asap$$BrowserMutationObserver) {\n            $$asap$$scheduleFlush = $$asap$$useMutationObserver();\n        } else if ($$asap$$isWorker) {\n            $$asap$$scheduleFlush = $$asap$$useMessageChannel();\n        } else {\n            $$asap$$scheduleFlush = $$asap$$useSetTimeout();\n        }\n\n        function $$$internal$$noop() {}\n        var $$$internal$$PENDING   = void 0;\n        var $$$internal$$FULFILLED = 1;\n        var $$$internal$$REJECTED  = 2;\n        var $$$internal$$GET_THEN_ERROR = new $$$internal$$ErrorObject();\n\n        function $$$internal$$selfFullfillment() {\n            return new TypeError(\"You cannot resolve a promise with itself\");\n        }\n\n        function $$$internal$$cannotReturnOwn() {\n            return new TypeError('A promises callback cannot return that same promise.')\n        }\n\n        function $$$internal$$getThen(promise) {\n            try {\n                return promise.then;\n            } catch(error) {\n                $$$internal$$GET_THEN_ERROR.error = error;\n                return $$$internal$$GET_THEN_ERROR;\n            }\n        }\n\n        function $$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n            try {\n                then.call(value, fulfillmentHandler, rejectionHandler);\n            } catch(e) {\n                return e;\n            }\n        }\n\n        function $$$internal$$handleForeignThenable(promise, thenable, then) {\n            $$asap$$default(function(promise) {\n                var sealed = false;\n                var error = $$$internal$$tryThen(then, thenable, function(value) {\n                    if (sealed) { return; }\n                    sealed = true;\n                    if (thenable !== value) {\n                        $$$internal$$resolve(promise, value);\n                    } else {\n                        $$$internal$$fulfill(promise, value);\n                    }\n                }, function(reason) {\n                    if (sealed) { return; }\n                    sealed = true;\n\n                    $$$internal$$reject(promise, reason);\n                }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n                if (!sealed && error) {\n                    sealed = true;\n                    $$$internal$$reject(promise, error);\n                }\n            }, promise);\n        }\n\n        function $$$internal$$handleOwnThenable(promise, thenable) {\n            if (thenable._state === $$$internal$$FULFILLED) {\n                $$$internal$$fulfill(promise, thenable._result);\n            } else if (promise._state === $$$internal$$REJECTED) {\n                $$$internal$$reject(promise, thenable._result);\n            } else {\n                $$$internal$$subscribe(thenable, undefined, function(value) {\n                    $$$internal$$resolve(promise, value);\n                }, function(reason) {\n                    $$$internal$$reject(promise, reason);\n                });\n            }\n        }\n\n        function $$$internal$$handleMaybeThenable(promise, maybeThenable) {\n            if (maybeThenable.constructor === promise.constructor) {\n                $$$internal$$handleOwnThenable(promise, maybeThenable);\n            } else {\n                var then = $$$internal$$getThen(maybeThenable);\n\n                if (then === $$$internal$$GET_THEN_ERROR) {\n                    $$$internal$$reject(promise, $$$internal$$GET_THEN_ERROR.error);\n                } else if (then === undefined) {\n                    $$$internal$$fulfill(promise, maybeThenable);\n                } else if ($$utils$$isFunction(then)) {\n                    $$$internal$$handleForeignThenable(promise, maybeThenable, then);\n                } else {\n                    $$$internal$$fulfill(promise, maybeThenable);\n                }\n            }\n        }\n\n        function $$$internal$$resolve(promise, value) {\n            if (promise === value) {\n                $$$internal$$reject(promise, $$$internal$$selfFullfillment());\n            } else if ($$utils$$objectOrFunction(value)) {\n                $$$internal$$handleMaybeThenable(promise, value);\n            } else {\n                $$$internal$$fulfill(promise, value);\n            }\n        }\n\n        function $$$internal$$publishRejection(promise) {\n            if (promise._onerror) {\n                promise._onerror(promise._result);\n            }\n\n            $$$internal$$publish(promise);\n        }\n\n        function $$$internal$$fulfill(promise, value) {\n            if (promise._state !== $$$internal$$PENDING) { return; }\n\n            promise._result = value;\n            promise._state = $$$internal$$FULFILLED;\n\n            if (promise._subscribers.length === 0) {\n            } else {\n                $$asap$$default($$$internal$$publish, promise);\n            }\n        }\n\n        function $$$internal$$reject(promise, reason) {\n            if (promise._state !== $$$internal$$PENDING) { return; }\n            promise._state = $$$internal$$REJECTED;\n            promise._result = reason;\n\n            $$asap$$default($$$internal$$publishRejection, promise);\n        }\n\n        function $$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n            var subscribers = parent._subscribers;\n            var length = subscribers.length;\n\n            parent._onerror = null;\n\n            subscribers[length] = child;\n            subscribers[length + $$$internal$$FULFILLED] = onFulfillment;\n            subscribers[length + $$$internal$$REJECTED]  = onRejection;\n\n            if (length === 0 && parent._state) {\n                $$asap$$default($$$internal$$publish, parent);\n            }\n        }\n\n        function $$$internal$$publish(promise) {\n            var subscribers = promise._subscribers;\n            var settled = promise._state;\n\n            if (subscribers.length === 0) { return; }\n\n            var child, callback, detail = promise._result;\n\n            for (var i = 0; i < subscribers.length; i += 3) {\n                child = subscribers[i];\n                callback = subscribers[i + settled];\n\n                if (child) {\n                    $$$internal$$invokeCallback(settled, child, callback, detail);\n                } else {\n                    callback(detail);\n                }\n            }\n\n            promise._subscribers.length = 0;\n        }\n\n        function $$$internal$$ErrorObject() {\n            this.error = null;\n        }\n\n        var $$$internal$$TRY_CATCH_ERROR = new $$$internal$$ErrorObject();\n\n        function $$$internal$$tryCatch(callback, detail) {\n            try {\n                return callback(detail);\n            } catch(e) {\n                $$$internal$$TRY_CATCH_ERROR.error = e;\n                return $$$internal$$TRY_CATCH_ERROR;\n            }\n        }\n\n        function $$$internal$$invokeCallback(settled, promise, callback, detail) {\n            var hasCallback = $$utils$$isFunction(callback),\n            value, error, succeeded, failed;\n\n            if (hasCallback) {\n                value = $$$internal$$tryCatch(callback, detail);\n\n                if (value === $$$internal$$TRY_CATCH_ERROR) {\n                    failed = true;\n                    error = value.error;\n                    value = null;\n                } else {\n                    succeeded = true;\n                }\n\n                if (promise === value) {\n                    $$$internal$$reject(promise, $$$internal$$cannotReturnOwn());\n                    return;\n                }\n\n            } else {\n                value = detail;\n                succeeded = true;\n            }\n\n            if (promise._state !== $$$internal$$PENDING) {\n                // noop\n            } else if (hasCallback && succeeded) {\n                $$$internal$$resolve(promise, value);\n            } else if (failed) {\n                $$$internal$$reject(promise, error);\n            } else if (settled === $$$internal$$FULFILLED) {\n                $$$internal$$fulfill(promise, value);\n            } else if (settled === $$$internal$$REJECTED) {\n                $$$internal$$reject(promise, value);\n            }\n        }\n\n        function $$$internal$$initializePromise(promise, resolver) {\n            try {\n                resolver(function resolvePromise(value){\n                    $$$internal$$resolve(promise, value);\n                }, function rejectPromise(reason) {\n                    $$$internal$$reject(promise, reason);\n                });\n            } catch(e) {\n                $$$internal$$reject(promise, e);\n            }\n        }\n\n        function $$$enumerator$$makeSettledResult(state, position, value) {\n            if (state === $$$internal$$FULFILLED) {\n                return {\n                    state: 'fulfilled',\n                    value: value\n                };\n            } else {\n                return {\n                    state: 'rejected',\n                    reason: value\n                };\n            }\n        }\n\n        function $$$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {\n            this._instanceConstructor = Constructor;\n            this.promise = new Constructor($$$internal$$noop, label);\n            this._abortOnReject = abortOnReject;\n\n            if (this._validateInput(input)) {\n                this._input     = input;\n                this.length     = input.length;\n                this._remaining = input.length;\n\n                this._init();\n\n                if (this.length === 0) {\n                    $$$internal$$fulfill(this.promise, this._result);\n                } else {\n                    this.length = this.length || 0;\n                    this._enumerate();\n                    if (this._remaining === 0) {\n                        $$$internal$$fulfill(this.promise, this._result);\n                    }\n                }\n            } else {\n                $$$internal$$reject(this.promise, this._validationError());\n            }\n        }\n\n        $$$enumerator$$Enumerator.prototype._validateInput = function(input) {\n            return $$utils$$isArray(input);\n        };\n\n        $$$enumerator$$Enumerator.prototype._validationError = function() {\n            return new Error('Array Methods must be provided an Array');\n        };\n\n        $$$enumerator$$Enumerator.prototype._init = function() {\n            this._result = new Array(this.length);\n        };\n\n        var $$$enumerator$$default = $$$enumerator$$Enumerator;\n\n        $$$enumerator$$Enumerator.prototype._enumerate = function() {\n            var length  = this.length;\n            var promise = this.promise;\n            var input   = this._input;\n\n            for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\n                this._eachEntry(input[i], i);\n            }\n        };\n\n        $$$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n            var c = this._instanceConstructor;\n            if ($$utils$$isMaybeThenable(entry)) {\n                if (entry.constructor === c && entry._state !== $$$internal$$PENDING) {\n                    entry._onerror = null;\n                    this._settledAt(entry._state, i, entry._result);\n                } else {\n                    this._willSettleAt(c.resolve(entry), i);\n                }\n            } else {\n                this._remaining--;\n                this._result[i] = this._makeResult($$$internal$$FULFILLED, i, entry);\n            }\n        };\n\n        $$$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n            var promise = this.promise;\n\n            if (promise._state === $$$internal$$PENDING) {\n                this._remaining--;\n\n                if (this._abortOnReject && state === $$$internal$$REJECTED) {\n                    $$$internal$$reject(promise, value);\n                } else {\n                    this._result[i] = this._makeResult(state, i, value);\n                }\n            }\n\n            if (this._remaining === 0) {\n                $$$internal$$fulfill(promise, this._result);\n            }\n        };\n\n        $$$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {\n            return value;\n        };\n\n        $$$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n            var enumerator = this;\n\n            $$$internal$$subscribe(promise, undefined, function(value) {\n                enumerator._settledAt($$$internal$$FULFILLED, i, value);\n            }, function(reason) {\n                enumerator._settledAt($$$internal$$REJECTED, i, reason);\n            });\n        };\n\n        var $$promise$all$$default = function all(entries, label) {\n            return new $$$enumerator$$default(this, entries, true /* abort on reject */, label).promise;\n        };\n\n        var $$promise$race$$default = function race(entries, label) {\n            /*jshint validthis:true */\n            var Constructor = this;\n\n            var promise = new Constructor($$$internal$$noop, label);\n\n            if (!$$utils$$isArray(entries)) {\n                $$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n                return promise;\n            }\n\n            var length = entries.length;\n\n            function onFulfillment(value) {\n                $$$internal$$resolve(promise, value);\n            }\n\n            function onRejection(reason) {\n                $$$internal$$reject(promise, reason);\n            }\n\n            for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\n                $$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n            }\n\n            return promise;\n        };\n\n        var $$promise$resolve$$default = function resolve(object, label) {\n            /*jshint validthis:true */\n            var Constructor = this;\n\n            if (object && typeof object === 'object' && object.constructor === Constructor) {\n                return object;\n            }\n\n            var promise = new Constructor($$$internal$$noop, label);\n            $$$internal$$resolve(promise, object);\n            return promise;\n        };\n\n        var $$promise$reject$$default = function reject(reason, label) {\n            /*jshint validthis:true */\n            var Constructor = this;\n            var promise = new Constructor($$$internal$$noop, label);\n            $$$internal$$reject(promise, reason);\n            return promise;\n        };\n\n        var $$es6$promise$promise$$counter = 0;\n\n        function $$es6$promise$promise$$needsResolver() {\n            throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n        }\n\n        function $$es6$promise$promise$$needsNew() {\n            throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n        }\n\n        var $$es6$promise$promise$$default = $$es6$promise$promise$$Promise;\n\n        /**\n         Promise objects represent the eventual result of an asynchronous operation. The\n         primary way of interacting with a promise is through its `then` method, which\n         registers callbacks to receive either a promiseâ€™s eventual value or the reason\n         why the promise cannot be fulfilled.\n\n         Terminology\n         -----------\n\n         - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n         - `thenable` is an object or function that defines a `then` method.\n         - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n         - `exception` is a value that is thrown using the throw statement.\n         - `reason` is a value that indicates why a promise was rejected.\n         - `settled` the final resting state of a promise, fulfilled or rejected.\n\n         A promise can be in one of three states: pending, fulfilled, or rejected.\n\n         Promises that are fulfilled have a fulfillment value and are in the fulfilled\n         state.  Promises that are rejected have a rejection reason and are in the\n         rejected state.  A fulfillment value is never a thenable.\n\n         Promises can also be said to *resolve* a value.  If this value is also a\n         promise, then the original promise's settled state will match the value's\n         settled state.  So a promise that *resolves* a promise that rejects will\n         itself reject, and a promise that *resolves* a promise that fulfills will\n         itself fulfill.\n\n\n         Basic Usage:\n         ------------\n\n         ```js\n         var promise = new Promise(function(resolve, reject) {\n         // on success\n         resolve(value);\n\n         // on failure\n         reject(reason);\n         });\n\n         promise.then(function(value) {\n         // on fulfillment\n         }, function(reason) {\n         // on rejection\n         });\n         ```\n\n         Advanced Usage:\n         ---------------\n\n         Promises shine when abstracting away asynchronous interactions such as\n         `XMLHttpRequest`s.\n\n         ```js\n         function getJSON(url) {\n         return new Promise(function(resolve, reject){\n         var xhr = new XMLHttpRequest();\n\n         xhr.open('GET', url);\n         xhr.onreadystatechange = handler;\n         xhr.responseType = 'json';\n         xhr.setRequestHeader('Accept', 'application/json');\n         xhr.send();\n\n         function handler() {\n         if (this.readyState === this.DONE) {\n         if (this.status === 200) {\n         resolve(this.response);\n         } else {\n         reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n         }\n         }\n         };\n         });\n         }\n\n         getJSON('/posts.json').then(function(json) {\n         // on fulfillment\n         }, function(reason) {\n         // on rejection\n         });\n         ```\n\n         Unlike callbacks, promises are great composable primitives.\n\n         ```js\n         Promise.all([\n         getJSON('/posts'),\n         getJSON('/comments')\n         ]).then(function(values){\n         values[0] // => postsJSON\n         values[1] // => commentsJSON\n\n         return values;\n         });\n         ```\n\n         @class Promise\n         @param {function} resolver\n         @param {String} label optional string for labeling the promise.\n         Useful for tooling.\n         @constructor\n         */\n        function $$es6$promise$promise$$Promise(resolver, label) {\n            this._id = $$es6$promise$promise$$counter++;\n            this._label = label;\n            this._state = undefined;\n            this._result = undefined;\n            this._subscribers = [];\n\n            if ($$$internal$$noop !== resolver) {\n                if (!$$utils$$isFunction(resolver)) {\n                    $$es6$promise$promise$$needsResolver();\n                }\n\n                if (!(this instanceof $$es6$promise$promise$$Promise)) {\n                    $$es6$promise$promise$$needsNew();\n                }\n\n                $$$internal$$initializePromise(this, resolver);\n            }\n        }\n\n        $$es6$promise$promise$$Promise.all = $$promise$all$$default;\n        $$es6$promise$promise$$Promise.race = $$promise$race$$default;\n        $$es6$promise$promise$$Promise.resolve = $$promise$resolve$$default;\n        $$es6$promise$promise$$Promise.reject = $$promise$reject$$default;\n\n        $$es6$promise$promise$$Promise.prototype = {\n            constructor: $$es6$promise$promise$$Promise,\n\n            /**\n             The primary way of interacting with a promise is through its `then` method,\n             which registers callbacks to receive either a promise's eventual value or the\n             reason why the promise cannot be fulfilled.\n\n             ```js\n             findUser().then(function(user){\n             // user is available\n             }, function(reason){\n             // user is unavailable, and you are given the reason why\n             });\n             ```\n\n             Chaining\n             --------\n\n             The return value of `then` is itself a promise.  This second, 'downstream'\n             promise is resolved with the return value of the first promise's fulfillment\n             or rejection handler, or rejected if the handler throws an exception.\n\n             ```js\n             findUser().then(function (user) {\n             return user.name;\n             }, function (reason) {\n             return 'default name';\n             }).then(function (userName) {\n             // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n             // will be `'default name'`\n             });\n\n             findUser().then(function (user) {\n             throw new Error('Found user, but still unhappy');\n             }, function (reason) {\n             throw new Error('`findUser` rejected and we're unhappy');\n             }).then(function (value) {\n             // never reached\n             }, function (reason) {\n             // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n             // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n             });\n             ```\n             If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n             ```js\n             findUser().then(function (user) {\n             throw new PedagogicalException('Upstream error');\n             }).then(function (value) {\n             // never reached\n             }).then(function (value) {\n             // never reached\n             }, function (reason) {\n             // The `PedgagocialException` is propagated all the way down to here\n             });\n             ```\n\n             Assimilation\n             ------------\n\n             Sometimes the value you want to propagate to a downstream promise can only be\n             retrieved asynchronously. This can be achieved by returning a promise in the\n             fulfillment or rejection handler. The downstream promise will then be pending\n             until the returned promise is settled. This is called *assimilation*.\n\n             ```js\n             findUser().then(function (user) {\n             return findCommentsByAuthor(user);\n             }).then(function (comments) {\n             // The user's comments are now available\n             });\n             ```\n\n             If the assimliated promise rejects, then the downstream promise will also reject.\n\n             ```js\n             findUser().then(function (user) {\n             return findCommentsByAuthor(user);\n             }).then(function (comments) {\n             // If `findCommentsByAuthor` fulfills, we'll have the value here\n             }, function (reason) {\n             // If `findCommentsByAuthor` rejects, we'll have the reason here\n             });\n             ```\n\n             Simple Example\n             --------------\n\n             Synchronous Example\n\n             ```javascript\n             var result;\n\n             try {\n             result = findResult();\n             // success\n             } catch(reason) {\n             // failure\n             }\n             ```\n\n             Errback Example\n\n             ```js\n             findResult(function(result, err){\n             if (err) {\n             // failure\n             } else {\n             // success\n             }\n             });\n             ```\n\n             Promise Example;\n\n             ```javascript\n             findResult().then(function(result){\n             // success\n             }, function(reason){\n             // failure\n             });\n             ```\n\n             Advanced Example\n             --------------\n\n             Synchronous Example\n\n             ```javascript\n             var author, books;\n\n             try {\n             author = findAuthor();\n             books  = findBooksByAuthor(author);\n             // success\n             } catch(reason) {\n             // failure\n             }\n             ```\n\n             Errback Example\n\n             ```js\n\n             function foundBooks(books) {\n\n             }\n\n             function failure(reason) {\n\n             }\n\n             findAuthor(function(author, err){\n             if (err) {\n             failure(err);\n             // failure\n             } else {\n             try {\n             findBoooksByAuthor(author, function(books, err) {\n             if (err) {\n             failure(err);\n             } else {\n             try {\n             foundBooks(books);\n             } catch(reason) {\n             failure(reason);\n             }\n             }\n             });\n             } catch(error) {\n             failure(err);\n             }\n             // success\n             }\n             });\n             ```\n\n             Promise Example;\n\n             ```javascript\n             findAuthor().\n             then(findBooksByAuthor).\n             then(function(books){\n             // found books\n             }).catch(function(reason){\n             // something went wrong\n             });\n             ```\n\n             @method then\n             @param {Function} onFulfilled\n             @param {Function} onRejected\n             @param {String} label optional string for labeling the promise.\n             Useful for tooling.\n             @return {Promise}\n             */\n            then: function(onFulfillment, onRejection, label) {\n                var parent = this;\n                var state = parent._state;\n\n                if (state === $$$internal$$FULFILLED && !onFulfillment || state === $$$internal$$REJECTED && !onRejection) {\n                    return this;\n                }\n\n                parent._onerror = null;\n\n                var child = new this.constructor($$$internal$$noop, label);\n                var result = parent._result;\n\n                if (state) {\n                    var callback = arguments[state - 1];\n                    $$asap$$default(function(){\n                        $$$internal$$invokeCallback(state, child, callback, result);\n                    });\n                } else {\n                    $$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n                }\n\n                return child;\n            },\n\n            /**\n             `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n             as the catch block of a try/catch statement.\n\n             ```js\n             function findAuthor(){\n             throw new Error('couldn't find that author');\n             }\n\n             // synchronous\n             try {\n             findAuthor();\n             } catch(reason) {\n             // something went wrong\n             }\n\n             // async with promises\n             findAuthor().catch(function(reason){\n             // something went wrong\n             });\n             ```\n\n             @method catch\n             @param {Function} onRejection\n             @param {String} label optional string for labeling the promise.\n             Useful for tooling.\n             @return {Promise}\n             */\n            'catch': function(onRejection, label) {\n                return this.then(null, onRejection, label);\n            }\n        };\n\n        var $$es6$promise$polyfill$$default = function polyfill() {\n            var local;\n\n            if (typeof global !== 'undefined') {\n                local = global;\n            } else if (typeof window !== 'undefined' && window.document) {\n                local = window;\n            } else {\n                local = self;\n            }\n\n            var es6PromiseSupport =\n                \"Promise\" in local &&\n                // Some of these methods are missing from\n                // Firefox/Chrome experimental implementations\n                \"resolve\" in local.Promise &&\n                \"reject\" in local.Promise &&\n                \"all\" in local.Promise &&\n                \"race\" in local.Promise &&\n                // Older version of the spec had a resolver object\n                // as the arg rather than a function\n                (function() {\n                    var resolve;\n                    new local.Promise(function(r) { resolve = r; });\n                    return $$utils$$isFunction(resolve);\n                }());\n\n            if (!es6PromiseSupport) {\n                local.Promise = $$es6$promise$promise$$default;\n            }\n        };\n\n        var es6$promise$umd$$ES6Promise = {\n            Promise: $$es6$promise$promise$$default,\n            polyfill: $$es6$promise$polyfill$$default\n        };\n\n        // Calling polyfill.\n        $$es6$promise$polyfill$$default();\n\n        /* global define:true module:true window: true */\n/*\n        if (typeof define === 'function' && define['amd']) {\n            define(function() { return es6$promise$umd$$ES6Promise; });\n        } else if (typeof module !== 'undefined' && module['exports']) {\n            module['exports'] = es6$promise$umd$$ES6Promise;\n        } else if (typeof this !== 'undefined') {\n            this['ES6Promise'] = es6$promise$umd$$ES6Promise;\n        }\n*/\n    }).call(this);\n}\n });\n","zip":"require(\"tfw.promise\",function(t,n){window.Promise||function(){\"use strict\";function t(t){return\"function\"==typeof t||\"object\"==typeof t&&null!==t}function n(t){return\"function\"==typeof t}function e(t){return\"object\"==typeof t&&null!==t}function r(){}function o(){return function(){process.nextTick(c)}}function i(){var t=0,n=new q(c),e=document.createTextNode(\"\");return n.observe(e,{characterData:!0}),function(){e.data=t=++t%2}}function s(){var t=new MessageChannel;return t.port1.onmessage=c,function(){t.port2.postMessage(0)}}function u(){return function(){setTimeout(c,1)}}function c(){for(var t=0;Y>t;t+=2){var n=K[t],e=K[t+1];n(e),K[t]=void 0,K[t+1]=void 0}Y=0}function a(){}function f(){return new TypeError(\"You cannot resolve a promise with itself\")}function l(){return new TypeError(\"A promises callback cannot return that same promise.\")}function h(t){try{return t.then}catch(n){return z.error=n,z}}function p(t,n,e,r){try{t.call(n,e,r)}catch(o){return o}}function _(t,n,e){x(function(t){var r=!1,o=p(e,n,function(e){r||(r=!0,n!==e?m(t,e):w(t,e))},function(n){r||(r=!0,b(t,n))},\"Settle: \"+(t._label||\" unknown promise\"));!r&&o&&(r=!0,b(t,o))},t)}function v(t,n){n._state===U?w(t,n._result):t._state===W?b(t,n._result):g(n,void 0,function(n){m(t,n)},function(n){b(t,n)})}function d(t,e){if(e.constructor===t.constructor)v(t,e);else{var r=h(e);r===z?b(t,z.error):void 0===r?w(t,e):n(r)?_(t,e,r):w(t,e)}}function m(n,e){n===e?b(n,f()):t(e)?d(n,e):w(n,e)}function y(t){t._onerror&&t._onerror(t._result),A(t)}function w(t,n){t._state===N&&(t._result=n,t._state=U,0===t._subscribers.length||x(A,t))}function b(t,n){t._state===N&&(t._state=W,t._result=n,x(y,t))}function g(t,n,e,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=n,o[i+U]=e,o[i+W]=r,0===i&&t._state&&x(A,t)}function A(t){var n=t._subscribers,e=t._state;if(0!==n.length){for(var r,o,i=t._result,s=0;s<n.length;s+=3)r=n[s],o=n[s+e],r?P(e,r,o,i):o(i);t._subscribers.length=0}}function j(){this.error=null}function E(t,n){try{return t(n)}catch(e){return B.error=e,B}}function P(t,e,r,o){var i,s,u,c,a=n(r);if(a){if(i=E(r,o),i===B?(c=!0,s=i.error,i=null):u=!0,e===i)return void b(e,l())}else i=o,u=!0;e._state!==N||(a&&u?m(e,i):c?b(e,s):t===U?w(e,i):t===W&&b(e,i))}function T(t,n){try{n(function(n){m(t,n)},function(n){b(t,n)})}catch(e){b(t,e)}}function S(t,n,e,r){this._instanceConstructor=t,this.promise=new t(a,r),this._abortOnReject=e,this._validateInput(n)?(this._input=n,this.length=n.length,this._remaining=n.length,this._init(),0===this.length?w(this.promise,this._result):(this.length=this.length||0,this._enumerate(),0===this._remaining&&w(this.promise,this._result))):b(this.promise,this._validationError())}function k(){throw new TypeError(\"You must pass a resolver function as the first argument to the promise constructor\")}function M(){throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\")}function O(t,e){this._id=V++,this._label=e,this._state=void 0,this._result=void 0,this._subscribers=[],a!==t&&(n(t)||k(),this instanceof O||M(),T(this,t))}var C;C=Array.isArray?Array.isArray:function(t){return\"[object Array]\"===Object.prototype.toString.call(t)};var R,D=C,Y=(Date.now||function(){return(new Date).getTime()},Object.create||function(t){if(arguments.length>1)throw new Error(\"Second argument not supported\");if(\"object\"!=typeof t)throw new TypeError(\"Argument must be an object\");return r.prototype=t,new r},0),x=function(t,n){K[Y]=t,K[Y+1]=n,Y+=2,2===Y&&R()},I=\"undefined\"!=typeof window?window:{},q=I.MutationObserver||I.WebKitMutationObserver,F=\"undefined\"!=typeof Uint8ClampedArray&&\"undefined\"!=typeof importScripts&&\"undefined\"!=typeof MessageChannel,K=new Array(1e3);R=\"undefined\"!=typeof process&&\"[object process]\"==={}.toString.call(process)?o():q?i():F?s():u();var N=void 0,U=1,W=2,z=new j,B=new j;S.prototype._validateInput=function(t){return D(t)},S.prototype._validationError=function(){return new Error(\"Array Methods must be provided an Array\")},S.prototype._init=function(){this._result=new Array(this.length)};var G=S;S.prototype._enumerate=function(){for(var t=this.length,n=this.promise,e=this._input,r=0;n._state===N&&t>r;r++)this._eachEntry(e[r],r)},S.prototype._eachEntry=function(t,n){var r=this._instanceConstructor;e(t)?t.constructor===r&&t._state!==N?(t._onerror=null,this._settledAt(t._state,n,t._result)):this._willSettleAt(r.resolve(t),n):(this._remaining--,this._result[n]=this._makeResult(U,n,t))},S.prototype._settledAt=function(t,n,e){var r=this.promise;r._state===N&&(this._remaining--,this._abortOnReject&&t===W?b(r,e):this._result[n]=this._makeResult(t,n,e)),0===this._remaining&&w(r,this._result)},S.prototype._makeResult=function(t,n,e){return e},S.prototype._willSettleAt=function(t,n){var e=this;g(t,void 0,function(t){e._settledAt(U,n,t)},function(t){e._settledAt(W,n,t)})};var H=function(t,n){return new G(this,t,!0,n).promise},J=function(t,n){function e(t){m(i,t)}function r(t){b(i,t)}var o=this,i=new o(a,n);if(!D(t))return b(i,new TypeError(\"You must pass an array to race.\")),i;for(var s=t.length,u=0;i._state===N&&s>u;u++)g(o.resolve(t[u]),void 0,e,r);return i},L=function(t,n){var e=this;if(t&&\"object\"==typeof t&&t.constructor===e)return t;var r=new e(a,n);return m(r,t),r},Q=function(t,n){var e=this,r=new e(a,n);return b(r,t),r},V=0,X=O;O.all=H,O.race=J,O.resolve=L,O.reject=Q,O.prototype={constructor:O,then:function(t,n,e){var r=this,o=r._state;if(o===U&&!t||o===W&&!n)return this;r._onerror=null;var i=new this.constructor(a,e),s=r._result;if(o){var u=arguments[o-1];x(function(){P(o,i,u,s)})}else g(r,i,t,n);return i},\"catch\":function(t,n){return this.then(null,t,n)}};var Z=function(){var t;t=\"undefined\"!=typeof global?global:\"undefined\"!=typeof window&&window.document?window:self;var e=\"Promise\"in t&&\"resolve\"in t.Promise&&\"reject\"in t.Promise&&\"all\"in t.Promise&&\"race\"in t.Promise&&function(){var e;return new t.Promise(function(t){e=t}),n(e)}();e||(t.Promise=X)};Z()}.call(this)});\n//# sourceMappingURL=tfw.promise.js.map","map":{"version":3,"file":"tfw.promise.js.map","sources":["tfw.promise.js"],"sourcesContent":["require( 'tfw.promise', function(exports, module) {  /**\n * Polyfill for Promise...\n */\n/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   2.0.0\n */\n\nif (!window.Promise) {\n    (function() {\n        \"use strict\";\n\n        function $$utils$$objectOrFunction(x) {\n            return typeof x === 'function' || (typeof x === 'object' && x !== null);\n        }\n\n        function $$utils$$isFunction(x) {\n            return typeof x === 'function';\n        }\n\n        function $$utils$$isMaybeThenable(x) {\n            return typeof x === 'object' && x !== null;\n        }\n\n        var $$utils$$_isArray;\n\n        if (!Array.isArray) {\n            $$utils$$_isArray = function (x) {\n                return Object.prototype.toString.call(x) === '[object Array]';\n            };\n        } else {\n            $$utils$$_isArray = Array.isArray;\n        }\n\n        var $$utils$$isArray = $$utils$$_isArray;\n        var $$utils$$now = Date.now || function() { return new Date().getTime(); };\n        function $$utils$$F() { }\n\n        var $$utils$$o_create = (Object.create || function (o) {\n            if (arguments.length > 1) {\n                throw new Error('Second argument not supported');\n            }\n            if (typeof o !== 'object') {\n                throw new TypeError('Argument must be an object');\n            }\n            $$utils$$F.prototype = o;\n            return new $$utils$$F();\n        });\n\n        var $$asap$$len = 0;\n\n        var $$asap$$default = function asap(callback, arg) {\n            $$asap$$queue[$$asap$$len] = callback;\n            $$asap$$queue[$$asap$$len + 1] = arg;\n            $$asap$$len += 2;\n            if ($$asap$$len === 2) {\n                // If len is 1, that means that we need to schedule an async flush.\n                // If additional callbacks are queued before the queue is flushed, they\n                // will be processed by this flush that we are scheduling.\n                $$asap$$scheduleFlush();\n            }\n        };\n\n        var $$asap$$browserGlobal = (typeof window !== 'undefined') ? window : {};\n        var $$asap$$BrowserMutationObserver = $$asap$$browserGlobal.MutationObserver || $$asap$$browserGlobal.WebKitMutationObserver;\n\n        // test for web worker but not in IE10\n        var $$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n            typeof importScripts !== 'undefined' &&\n            typeof MessageChannel !== 'undefined';\n\n        // node\n        function $$asap$$useNextTick() {\n            return function() {\n                process.nextTick($$asap$$flush);\n            };\n        }\n\n        function $$asap$$useMutationObserver() {\n            var iterations = 0;\n            var observer = new $$asap$$BrowserMutationObserver($$asap$$flush);\n            var node = document.createTextNode('');\n            observer.observe(node, { characterData: true });\n\n            return function() {\n                node.data = (iterations = ++iterations % 2);\n            };\n        }\n\n        // web worker\n        function $$asap$$useMessageChannel() {\n            var channel = new MessageChannel();\n            channel.port1.onmessage = $$asap$$flush;\n            return function () {\n                channel.port2.postMessage(0);\n            };\n        }\n\n        function $$asap$$useSetTimeout() {\n            return function() {\n                setTimeout($$asap$$flush, 1);\n            };\n        }\n\n        var $$asap$$queue = new Array(1000);\n\n        function $$asap$$flush() {\n            for (var i = 0; i < $$asap$$len; i+=2) {\n                var callback = $$asap$$queue[i];\n                var arg = $$asap$$queue[i+1];\n\n                callback(arg);\n\n                $$asap$$queue[i] = undefined;\n                $$asap$$queue[i+1] = undefined;\n            }\n\n            $$asap$$len = 0;\n        }\n\n        var $$asap$$scheduleFlush;\n\n        // Decide what async method to use to triggering processing of queued callbacks:\n        if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n            $$asap$$scheduleFlush = $$asap$$useNextTick();\n        } else if ($$asap$$BrowserMutationObserver) {\n            $$asap$$scheduleFlush = $$asap$$useMutationObserver();\n        } else if ($$asap$$isWorker) {\n            $$asap$$scheduleFlush = $$asap$$useMessageChannel();\n        } else {\n            $$asap$$scheduleFlush = $$asap$$useSetTimeout();\n        }\n\n        function $$$internal$$noop() {}\n        var $$$internal$$PENDING   = void 0;\n        var $$$internal$$FULFILLED = 1;\n        var $$$internal$$REJECTED  = 2;\n        var $$$internal$$GET_THEN_ERROR = new $$$internal$$ErrorObject();\n\n        function $$$internal$$selfFullfillment() {\n            return new TypeError(\"You cannot resolve a promise with itself\");\n        }\n\n        function $$$internal$$cannotReturnOwn() {\n            return new TypeError('A promises callback cannot return that same promise.')\n        }\n\n        function $$$internal$$getThen(promise) {\n            try {\n                return promise.then;\n            } catch(error) {\n                $$$internal$$GET_THEN_ERROR.error = error;\n                return $$$internal$$GET_THEN_ERROR;\n            }\n        }\n\n        function $$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n            try {\n                then.call(value, fulfillmentHandler, rejectionHandler);\n            } catch(e) {\n                return e;\n            }\n        }\n\n        function $$$internal$$handleForeignThenable(promise, thenable, then) {\n            $$asap$$default(function(promise) {\n                var sealed = false;\n                var error = $$$internal$$tryThen(then, thenable, function(value) {\n                    if (sealed) { return; }\n                    sealed = true;\n                    if (thenable !== value) {\n                        $$$internal$$resolve(promise, value);\n                    } else {\n                        $$$internal$$fulfill(promise, value);\n                    }\n                }, function(reason) {\n                    if (sealed) { return; }\n                    sealed = true;\n\n                    $$$internal$$reject(promise, reason);\n                }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n                if (!sealed && error) {\n                    sealed = true;\n                    $$$internal$$reject(promise, error);\n                }\n            }, promise);\n        }\n\n        function $$$internal$$handleOwnThenable(promise, thenable) {\n            if (thenable._state === $$$internal$$FULFILLED) {\n                $$$internal$$fulfill(promise, thenable._result);\n            } else if (promise._state === $$$internal$$REJECTED) {\n                $$$internal$$reject(promise, thenable._result);\n            } else {\n                $$$internal$$subscribe(thenable, undefined, function(value) {\n                    $$$internal$$resolve(promise, value);\n                }, function(reason) {\n                    $$$internal$$reject(promise, reason);\n                });\n            }\n        }\n\n        function $$$internal$$handleMaybeThenable(promise, maybeThenable) {\n            if (maybeThenable.constructor === promise.constructor) {\n                $$$internal$$handleOwnThenable(promise, maybeThenable);\n            } else {\n                var then = $$$internal$$getThen(maybeThenable);\n\n                if (then === $$$internal$$GET_THEN_ERROR) {\n                    $$$internal$$reject(promise, $$$internal$$GET_THEN_ERROR.error);\n                } else if (then === undefined) {\n                    $$$internal$$fulfill(promise, maybeThenable);\n                } else if ($$utils$$isFunction(then)) {\n                    $$$internal$$handleForeignThenable(promise, maybeThenable, then);\n                } else {\n                    $$$internal$$fulfill(promise, maybeThenable);\n                }\n            }\n        }\n\n        function $$$internal$$resolve(promise, value) {\n            if (promise === value) {\n                $$$internal$$reject(promise, $$$internal$$selfFullfillment());\n            } else if ($$utils$$objectOrFunction(value)) {\n                $$$internal$$handleMaybeThenable(promise, value);\n            } else {\n                $$$internal$$fulfill(promise, value);\n            }\n        }\n\n        function $$$internal$$publishRejection(promise) {\n            if (promise._onerror) {\n                promise._onerror(promise._result);\n            }\n\n            $$$internal$$publish(promise);\n        }\n\n        function $$$internal$$fulfill(promise, value) {\n            if (promise._state !== $$$internal$$PENDING) { return; }\n\n            promise._result = value;\n            promise._state = $$$internal$$FULFILLED;\n\n            if (promise._subscribers.length === 0) {\n            } else {\n                $$asap$$default($$$internal$$publish, promise);\n            }\n        }\n\n        function $$$internal$$reject(promise, reason) {\n            if (promise._state !== $$$internal$$PENDING) { return; }\n            promise._state = $$$internal$$REJECTED;\n            promise._result = reason;\n\n            $$asap$$default($$$internal$$publishRejection, promise);\n        }\n\n        function $$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n            var subscribers = parent._subscribers;\n            var length = subscribers.length;\n\n            parent._onerror = null;\n\n            subscribers[length] = child;\n            subscribers[length + $$$internal$$FULFILLED] = onFulfillment;\n            subscribers[length + $$$internal$$REJECTED]  = onRejection;\n\n            if (length === 0 && parent._state) {\n                $$asap$$default($$$internal$$publish, parent);\n            }\n        }\n\n        function $$$internal$$publish(promise) {\n            var subscribers = promise._subscribers;\n            var settled = promise._state;\n\n            if (subscribers.length === 0) { return; }\n\n            var child, callback, detail = promise._result;\n\n            for (var i = 0; i < subscribers.length; i += 3) {\n                child = subscribers[i];\n                callback = subscribers[i + settled];\n\n                if (child) {\n                    $$$internal$$invokeCallback(settled, child, callback, detail);\n                } else {\n                    callback(detail);\n                }\n            }\n\n            promise._subscribers.length = 0;\n        }\n\n        function $$$internal$$ErrorObject() {\n            this.error = null;\n        }\n\n        var $$$internal$$TRY_CATCH_ERROR = new $$$internal$$ErrorObject();\n\n        function $$$internal$$tryCatch(callback, detail) {\n            try {\n                return callback(detail);\n            } catch(e) {\n                $$$internal$$TRY_CATCH_ERROR.error = e;\n                return $$$internal$$TRY_CATCH_ERROR;\n            }\n        }\n\n        function $$$internal$$invokeCallback(settled, promise, callback, detail) {\n            var hasCallback = $$utils$$isFunction(callback),\n            value, error, succeeded, failed;\n\n            if (hasCallback) {\n                value = $$$internal$$tryCatch(callback, detail);\n\n                if (value === $$$internal$$TRY_CATCH_ERROR) {\n                    failed = true;\n                    error = value.error;\n                    value = null;\n                } else {\n                    succeeded = true;\n                }\n\n                if (promise === value) {\n                    $$$internal$$reject(promise, $$$internal$$cannotReturnOwn());\n                    return;\n                }\n\n            } else {\n                value = detail;\n                succeeded = true;\n            }\n\n            if (promise._state !== $$$internal$$PENDING) {\n                // noop\n            } else if (hasCallback && succeeded) {\n                $$$internal$$resolve(promise, value);\n            } else if (failed) {\n                $$$internal$$reject(promise, error);\n            } else if (settled === $$$internal$$FULFILLED) {\n                $$$internal$$fulfill(promise, value);\n            } else if (settled === $$$internal$$REJECTED) {\n                $$$internal$$reject(promise, value);\n            }\n        }\n\n        function $$$internal$$initializePromise(promise, resolver) {\n            try {\n                resolver(function resolvePromise(value){\n                    $$$internal$$resolve(promise, value);\n                }, function rejectPromise(reason) {\n                    $$$internal$$reject(promise, reason);\n                });\n            } catch(e) {\n                $$$internal$$reject(promise, e);\n            }\n        }\n\n        function $$$enumerator$$makeSettledResult(state, position, value) {\n            if (state === $$$internal$$FULFILLED) {\n                return {\n                    state: 'fulfilled',\n                    value: value\n                };\n            } else {\n                return {\n                    state: 'rejected',\n                    reason: value\n                };\n            }\n        }\n\n        function $$$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {\n            this._instanceConstructor = Constructor;\n            this.promise = new Constructor($$$internal$$noop, label);\n            this._abortOnReject = abortOnReject;\n\n            if (this._validateInput(input)) {\n                this._input     = input;\n                this.length     = input.length;\n                this._remaining = input.length;\n\n                this._init();\n\n                if (this.length === 0) {\n                    $$$internal$$fulfill(this.promise, this._result);\n                } else {\n                    this.length = this.length || 0;\n                    this._enumerate();\n                    if (this._remaining === 0) {\n                        $$$internal$$fulfill(this.promise, this._result);\n                    }\n                }\n            } else {\n                $$$internal$$reject(this.promise, this._validationError());\n            }\n        }\n\n        $$$enumerator$$Enumerator.prototype._validateInput = function(input) {\n            return $$utils$$isArray(input);\n        };\n\n        $$$enumerator$$Enumerator.prototype._validationError = function() {\n            return new Error('Array Methods must be provided an Array');\n        };\n\n        $$$enumerator$$Enumerator.prototype._init = function() {\n            this._result = new Array(this.length);\n        };\n\n        var $$$enumerator$$default = $$$enumerator$$Enumerator;\n\n        $$$enumerator$$Enumerator.prototype._enumerate = function() {\n            var length  = this.length;\n            var promise = this.promise;\n            var input   = this._input;\n\n            for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\n                this._eachEntry(input[i], i);\n            }\n        };\n\n        $$$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n            var c = this._instanceConstructor;\n            if ($$utils$$isMaybeThenable(entry)) {\n                if (entry.constructor === c && entry._state !== $$$internal$$PENDING) {\n                    entry._onerror = null;\n                    this._settledAt(entry._state, i, entry._result);\n                } else {\n                    this._willSettleAt(c.resolve(entry), i);\n                }\n            } else {\n                this._remaining--;\n                this._result[i] = this._makeResult($$$internal$$FULFILLED, i, entry);\n            }\n        };\n\n        $$$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n            var promise = this.promise;\n\n            if (promise._state === $$$internal$$PENDING) {\n                this._remaining--;\n\n                if (this._abortOnReject && state === $$$internal$$REJECTED) {\n                    $$$internal$$reject(promise, value);\n                } else {\n                    this._result[i] = this._makeResult(state, i, value);\n                }\n            }\n\n            if (this._remaining === 0) {\n                $$$internal$$fulfill(promise, this._result);\n            }\n        };\n\n        $$$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {\n            return value;\n        };\n\n        $$$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n            var enumerator = this;\n\n            $$$internal$$subscribe(promise, undefined, function(value) {\n                enumerator._settledAt($$$internal$$FULFILLED, i, value);\n            }, function(reason) {\n                enumerator._settledAt($$$internal$$REJECTED, i, reason);\n            });\n        };\n\n        var $$promise$all$$default = function all(entries, label) {\n            return new $$$enumerator$$default(this, entries, true /* abort on reject */, label).promise;\n        };\n\n        var $$promise$race$$default = function race(entries, label) {\n            /*jshint validthis:true */\n            var Constructor = this;\n\n            var promise = new Constructor($$$internal$$noop, label);\n\n            if (!$$utils$$isArray(entries)) {\n                $$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n                return promise;\n            }\n\n            var length = entries.length;\n\n            function onFulfillment(value) {\n                $$$internal$$resolve(promise, value);\n            }\n\n            function onRejection(reason) {\n                $$$internal$$reject(promise, reason);\n            }\n\n            for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {\n                $$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n            }\n\n            return promise;\n        };\n\n        var $$promise$resolve$$default = function resolve(object, label) {\n            /*jshint validthis:true */\n            var Constructor = this;\n\n            if (object && typeof object === 'object' && object.constructor === Constructor) {\n                return object;\n            }\n\n            var promise = new Constructor($$$internal$$noop, label);\n            $$$internal$$resolve(promise, object);\n            return promise;\n        };\n\n        var $$promise$reject$$default = function reject(reason, label) {\n            /*jshint validthis:true */\n            var Constructor = this;\n            var promise = new Constructor($$$internal$$noop, label);\n            $$$internal$$reject(promise, reason);\n            return promise;\n        };\n\n        var $$es6$promise$promise$$counter = 0;\n\n        function $$es6$promise$promise$$needsResolver() {\n            throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n        }\n\n        function $$es6$promise$promise$$needsNew() {\n            throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n        }\n\n        var $$es6$promise$promise$$default = $$es6$promise$promise$$Promise;\n\n        /**\n         Promise objects represent the eventual result of an asynchronous operation. The\n         primary way of interacting with a promise is through its `then` method, which\n         registers callbacks to receive either a promiseâ€™s eventual value or the reason\n         why the promise cannot be fulfilled.\n\n         Terminology\n         -----------\n\n         - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n         - `thenable` is an object or function that defines a `then` method.\n         - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n         - `exception` is a value that is thrown using the throw statement.\n         - `reason` is a value that indicates why a promise was rejected.\n         - `settled` the final resting state of a promise, fulfilled or rejected.\n\n         A promise can be in one of three states: pending, fulfilled, or rejected.\n\n         Promises that are fulfilled have a fulfillment value and are in the fulfilled\n         state.  Promises that are rejected have a rejection reason and are in the\n         rejected state.  A fulfillment value is never a thenable.\n\n         Promises can also be said to *resolve* a value.  If this value is also a\n         promise, then the original promise's settled state will match the value's\n         settled state.  So a promise that *resolves* a promise that rejects will\n         itself reject, and a promise that *resolves* a promise that fulfills will\n         itself fulfill.\n\n\n         Basic Usage:\n         ------------\n\n         ```js\n         var promise = new Promise(function(resolve, reject) {\n         // on success\n         resolve(value);\n\n         // on failure\n         reject(reason);\n         });\n\n         promise.then(function(value) {\n         // on fulfillment\n         }, function(reason) {\n         // on rejection\n         });\n         ```\n\n         Advanced Usage:\n         ---------------\n\n         Promises shine when abstracting away asynchronous interactions such as\n         `XMLHttpRequest`s.\n\n         ```js\n         function getJSON(url) {\n         return new Promise(function(resolve, reject){\n         var xhr = new XMLHttpRequest();\n\n         xhr.open('GET', url);\n         xhr.onreadystatechange = handler;\n         xhr.responseType = 'json';\n         xhr.setRequestHeader('Accept', 'application/json');\n         xhr.send();\n\n         function handler() {\n         if (this.readyState === this.DONE) {\n         if (this.status === 200) {\n         resolve(this.response);\n         } else {\n         reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n         }\n         }\n         };\n         });\n         }\n\n         getJSON('/posts.json').then(function(json) {\n         // on fulfillment\n         }, function(reason) {\n         // on rejection\n         });\n         ```\n\n         Unlike callbacks, promises are great composable primitives.\n\n         ```js\n         Promise.all([\n         getJSON('/posts'),\n         getJSON('/comments')\n         ]).then(function(values){\n         values[0] // => postsJSON\n         values[1] // => commentsJSON\n\n         return values;\n         });\n         ```\n\n         @class Promise\n         @param {function} resolver\n         @param {String} label optional string for labeling the promise.\n         Useful for tooling.\n         @constructor\n         */\n        function $$es6$promise$promise$$Promise(resolver, label) {\n            this._id = $$es6$promise$promise$$counter++;\n            this._label = label;\n            this._state = undefined;\n            this._result = undefined;\n            this._subscribers = [];\n\n            if ($$$internal$$noop !== resolver) {\n                if (!$$utils$$isFunction(resolver)) {\n                    $$es6$promise$promise$$needsResolver();\n                }\n\n                if (!(this instanceof $$es6$promise$promise$$Promise)) {\n                    $$es6$promise$promise$$needsNew();\n                }\n\n                $$$internal$$initializePromise(this, resolver);\n            }\n        }\n\n        $$es6$promise$promise$$Promise.all = $$promise$all$$default;\n        $$es6$promise$promise$$Promise.race = $$promise$race$$default;\n        $$es6$promise$promise$$Promise.resolve = $$promise$resolve$$default;\n        $$es6$promise$promise$$Promise.reject = $$promise$reject$$default;\n\n        $$es6$promise$promise$$Promise.prototype = {\n            constructor: $$es6$promise$promise$$Promise,\n\n            /**\n             The primary way of interacting with a promise is through its `then` method,\n             which registers callbacks to receive either a promise's eventual value or the\n             reason why the promise cannot be fulfilled.\n\n             ```js\n             findUser().then(function(user){\n             // user is available\n             }, function(reason){\n             // user is unavailable, and you are given the reason why\n             });\n             ```\n\n             Chaining\n             --------\n\n             The return value of `then` is itself a promise.  This second, 'downstream'\n             promise is resolved with the return value of the first promise's fulfillment\n             or rejection handler, or rejected if the handler throws an exception.\n\n             ```js\n             findUser().then(function (user) {\n             return user.name;\n             }, function (reason) {\n             return 'default name';\n             }).then(function (userName) {\n             // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n             // will be `'default name'`\n             });\n\n             findUser().then(function (user) {\n             throw new Error('Found user, but still unhappy');\n             }, function (reason) {\n             throw new Error('`findUser` rejected and we're unhappy');\n             }).then(function (value) {\n             // never reached\n             }, function (reason) {\n             // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n             // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n             });\n             ```\n             If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n             ```js\n             findUser().then(function (user) {\n             throw new PedagogicalException('Upstream error');\n             }).then(function (value) {\n             // never reached\n             }).then(function (value) {\n             // never reached\n             }, function (reason) {\n             // The `PedgagocialException` is propagated all the way down to here\n             });\n             ```\n\n             Assimilation\n             ------------\n\n             Sometimes the value you want to propagate to a downstream promise can only be\n             retrieved asynchronously. This can be achieved by returning a promise in the\n             fulfillment or rejection handler. The downstream promise will then be pending\n             until the returned promise is settled. This is called *assimilation*.\n\n             ```js\n             findUser().then(function (user) {\n             return findCommentsByAuthor(user);\n             }).then(function (comments) {\n             // The user's comments are now available\n             });\n             ```\n\n             If the assimliated promise rejects, then the downstream promise will also reject.\n\n             ```js\n             findUser().then(function (user) {\n             return findCommentsByAuthor(user);\n             }).then(function (comments) {\n             // If `findCommentsByAuthor` fulfills, we'll have the value here\n             }, function (reason) {\n             // If `findCommentsByAuthor` rejects, we'll have the reason here\n             });\n             ```\n\n             Simple Example\n             --------------\n\n             Synchronous Example\n\n             ```javascript\n             var result;\n\n             try {\n             result = findResult();\n             // success\n             } catch(reason) {\n             // failure\n             }\n             ```\n\n             Errback Example\n\n             ```js\n             findResult(function(result, err){\n             if (err) {\n             // failure\n             } else {\n             // success\n             }\n             });\n             ```\n\n             Promise Example;\n\n             ```javascript\n             findResult().then(function(result){\n             // success\n             }, function(reason){\n             // failure\n             });\n             ```\n\n             Advanced Example\n             --------------\n\n             Synchronous Example\n\n             ```javascript\n             var author, books;\n\n             try {\n             author = findAuthor();\n             books  = findBooksByAuthor(author);\n             // success\n             } catch(reason) {\n             // failure\n             }\n             ```\n\n             Errback Example\n\n             ```js\n\n             function foundBooks(books) {\n\n             }\n\n             function failure(reason) {\n\n             }\n\n             findAuthor(function(author, err){\n             if (err) {\n             failure(err);\n             // failure\n             } else {\n             try {\n             findBoooksByAuthor(author, function(books, err) {\n             if (err) {\n             failure(err);\n             } else {\n             try {\n             foundBooks(books);\n             } catch(reason) {\n             failure(reason);\n             }\n             }\n             });\n             } catch(error) {\n             failure(err);\n             }\n             // success\n             }\n             });\n             ```\n\n             Promise Example;\n\n             ```javascript\n             findAuthor().\n             then(findBooksByAuthor).\n             then(function(books){\n             // found books\n             }).catch(function(reason){\n             // something went wrong\n             });\n             ```\n\n             @method then\n             @param {Function} onFulfilled\n             @param {Function} onRejected\n             @param {String} label optional string for labeling the promise.\n             Useful for tooling.\n             @return {Promise}\n             */\n            then: function(onFulfillment, onRejection, label) {\n                var parent = this;\n                var state = parent._state;\n\n                if (state === $$$internal$$FULFILLED && !onFulfillment || state === $$$internal$$REJECTED && !onRejection) {\n                    return this;\n                }\n\n                parent._onerror = null;\n\n                var child = new this.constructor($$$internal$$noop, label);\n                var result = parent._result;\n\n                if (state) {\n                    var callback = arguments[state - 1];\n                    $$asap$$default(function(){\n                        $$$internal$$invokeCallback(state, child, callback, result);\n                    });\n                } else {\n                    $$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n                }\n\n                return child;\n            },\n\n            /**\n             `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n             as the catch block of a try/catch statement.\n\n             ```js\n             function findAuthor(){\n             throw new Error('couldn't find that author');\n             }\n\n             // synchronous\n             try {\n             findAuthor();\n             } catch(reason) {\n             // something went wrong\n             }\n\n             // async with promises\n             findAuthor().catch(function(reason){\n             // something went wrong\n             });\n             ```\n\n             @method catch\n             @param {Function} onRejection\n             @param {String} label optional string for labeling the promise.\n             Useful for tooling.\n             @return {Promise}\n             */\n            'catch': function(onRejection, label) {\n                return this.then(null, onRejection, label);\n            }\n        };\n\n        var $$es6$promise$polyfill$$default = function polyfill() {\n            var local;\n\n            if (typeof global !== 'undefined') {\n                local = global;\n            } else if (typeof window !== 'undefined' && window.document) {\n                local = window;\n            } else {\n                local = self;\n            }\n\n            var es6PromiseSupport =\n                \"Promise\" in local &&\n                // Some of these methods are missing from\n                // Firefox/Chrome experimental implementations\n                \"resolve\" in local.Promise &&\n                \"reject\" in local.Promise &&\n                \"all\" in local.Promise &&\n                \"race\" in local.Promise &&\n                // Older version of the spec had a resolver object\n                // as the arg rather than a function\n                (function() {\n                    var resolve;\n                    new local.Promise(function(r) { resolve = r; });\n                    return $$utils$$isFunction(resolve);\n                }());\n\n            if (!es6PromiseSupport) {\n                local.Promise = $$es6$promise$promise$$default;\n            }\n        };\n\n        var es6$promise$umd$$ES6Promise = {\n            Promise: $$es6$promise$promise$$default,\n            polyfill: $$es6$promise$polyfill$$default\n        };\n\n        // Calling polyfill.\n        $$es6$promise$polyfill$$default();\n\n        /* global define:true module:true window: true */\n/*\n        if (typeof define === 'function' && define['amd']) {\n            define(function() { return es6$promise$umd$$ES6Promise; });\n        } else if (typeof module !== 'undefined' && module['exports']) {\n            module['exports'] = es6$promise$umd$$ES6Promise;\n        } else if (typeof this !== 'undefined') {\n            this['ES6Promise'] = es6$promise$umd$$ES6Promise;\n        }\n*/\n    }).call(this);\n}\n });\n"],"names":["require","exports","module","window","Promise","$$utils$$objectOrFunction","x","$$utils$$isFunction","$$utils$$isMaybeThenable","$$utils$$F","$$asap$$useNextTick","process","nextTick","$$asap$$flush","$$asap$$useMutationObserver","iterations","observer","$$asap$$BrowserMutationObserver","node","document","createTextNode","observe","characterData","data","$$asap$$useMessageChannel","channel","MessageChannel","port1","onmessage","port2","postMessage","$$asap$$useSetTimeout","setTimeout","i","$$asap$$len","callback","$$asap$$queue","arg","undefined","$$$internal$$noop","$$$internal$$selfFullfillment","TypeError","$$$internal$$cannotReturnOwn","$$$internal$$getThen","promise","then","error","$$$internal$$GET_THEN_ERROR","$$$internal$$tryThen","value","fulfillmentHandler","rejectionHandler","call","e","$$$internal$$handleForeignThenable","thenable","$$asap$$default","sealed","$$$internal$$resolve","$$$internal$$fulfill","reason","$$$internal$$reject","_label","$$$internal$$handleOwnThenable","_state","$$$internal$$FULFILLED","_result","$$$internal$$REJECTED","$$$internal$$subscribe","$$$internal$$handleMaybeThenable","maybeThenable","constructor","$$$internal$$publishRejection","_onerror","$$$internal$$publish","$$$internal$$PENDING","_subscribers","length","parent","child","onFulfillment","onRejection","subscribers","settled","detail","$$$internal$$invokeCallback","$$$internal$$ErrorObject","this","$$$internal$$tryCatch","$$$internal$$TRY_CATCH_ERROR","succeeded","failed","hasCallback","$$$internal$$initializePromise","resolver","$$$enumerator$$Enumerator","Constructor","input","abortOnReject","label","_instanceConstructor","_abortOnReject","_validateInput","_input","_remaining","_init","_enumerate","_validationError","$$es6$promise$promise$$needsResolver","$$es6$promise$promise$$needsNew","$$es6$promise$promise$$Promise","_id","$$es6$promise$promise$$counter","$$utils$$_isArray","Array","isArray","Object","prototype","toString","$$asap$$scheduleFlush","$$utils$$isArray","Date","now","getTime","create","o","arguments","Error","$$asap$$browserGlobal","MutationObserver","WebKitMutationObserver","$$asap$$isWorker","Uint8ClampedArray","importScripts","$$$enumerator$$default","_eachEntry","entry","c","_settledAt","_willSettleAt","resolve","_makeResult","state","enumerator","$$promise$all$$default","entries","$$promise$race$$default","$$promise$resolve$$default","object","$$promise$reject$$default","$$es6$promise$promise$$default","all","race","reject","result","catch","$$es6$promise$polyfill$$default","local","global","self","es6PromiseSupport","r"],"mappings":"AAAAA,QAAS,cAAe,SAASC,EAASC,GAWrCC,OAAOC,SACR,WACI,YAEA,SAASC,GAA0BC,GAC/B,MAAoB,kBAANA,IAAkC,gBAANA,IAAwB,OAANA,EAGhE,QAASC,GAAoBD,GACzB,MAAoB,kBAANA,GAGlB,QAASE,GAAyBF,GAC9B,MAAoB,gBAANA,IAAwB,OAANA,EAepC,QAASG,MAoCT,QAASC,KACL,MAAO,YACHC,QAAQC,SAASC,IAIzB,QAASC,KACL,GAAIC,GAAa,EACbC,EAAW,GAAIC,GAAgCJ,GAC/CK,EAAOC,SAASC,eAAe,GAGnC,OAFAJ,GAASK,QAAQH,GAAQI,eAAe,IAEjC,WACHJ,EAAKK,KAAQR,IAAeA,EAAa,GAKjD,QAASS,KACL,GAAIC,GAAU,GAAIC,eAElB,OADAD,GAAQE,MAAMC,UAAYf,EACnB,WACHY,EAAQI,MAAMC,YAAY,IAIlC,QAASC,KACL,MAAO,YACHC,WAAWnB,EAAe,IAMlC,QAASA,KACL,IAAK,GAAIoB,GAAI,EAAOC,EAAJD,EAAiBA,GAAG,EAAG,CACnC,GAAIE,GAAWC,EAAcH,GACzBI,EAAMD,EAAcH,EAAE,EAE1BE,GAASE,GAETD,EAAcH,GAAKK,OACnBF,EAAcH,EAAE,GAAKK,OAGzBJ,EAAc,EAgBlB,QAASK,MAMT,QAASC,KACL,MAAO,IAAIC,WAAU,4CAGzB,QAASC,KACL,MAAO,IAAID,WAAU,wDAGzB,QAASE,GAAqBC,GAC1B,IACI,MAAOA,GAAQC,KACjB,MAAMC,GAEJ,MADAC,GAA4BD,MAAQA,EAC7BC,GAIf,QAASC,GAAqBH,EAAMI,EAAOC,EAAoBC,GAC3D,IACIN,EAAKO,KAAKH,EAAOC,EAAoBC,GACvC,MAAME,GACJ,MAAOA,IAIf,QAASC,GAAmCV,EAASW,EAAUV,GAC3DW,EAAgB,SAASZ,GACrB,GAAIa,IAAS,EACTX,EAAQE,EAAqBH,EAAMU,EAAU,SAASN,GAClDQ,IACJA,GAAS,EACLF,IAAaN,EACbS,EAAqBd,EAASK,GAE9BU,EAAqBf,EAASK,KAEnC,SAASW,GACJH,IACJA,GAAS,EAETI,EAAoBjB,EAASgB,KAC9B,YAAchB,EAAQkB,QAAU,sBAE9BL,GAAUX,IACXW,GAAS,EACTI,EAAoBjB,EAASE,KAElCF,GAGP,QAASmB,GAA+BnB,EAASW,GACzCA,EAASS,SAAWC,EACpBN,EAAqBf,EAASW,EAASW,SAChCtB,EAAQoB,SAAWG,EAC1BN,EAAoBjB,EAASW,EAASW,SAEtCE,EAAuBb,EAAUjB,OAAW,SAASW,GACjDS,EAAqBd,EAASK,IAC/B,SAASW,GACRC,EAAoBjB,EAASgB,KAKzC,QAASS,GAAiCzB,EAAS0B,GAC/C,GAAIA,EAAcC,cAAgB3B,EAAQ2B,YACtCR,EAA+BnB,EAAS0B,OACrC,CACH,GAAIzB,GAAOF,EAAqB2B,EAE5BzB,KAASE,EACTc,EAAoBjB,EAASG,EAA4BD,OACzCR,SAATO,EACPc,EAAqBf,EAAS0B,GACvB/D,EAAoBsC,GAC3BS,EAAmCV,EAAS0B,EAAezB,GAE3Dc,EAAqBf,EAAS0B,IAK1C,QAASZ,GAAqBd,EAASK,GAC/BL,IAAYK,EACZY,EAAoBjB,EAASJ,KACtBnC,EAA0B4C,GACjCoB,EAAiCzB,EAASK,GAE1CU,EAAqBf,EAASK,GAItC,QAASuB,GAA8B5B,GAC/BA,EAAQ6B,UACR7B,EAAQ6B,SAAS7B,EAAQsB,SAG7BQ,EAAqB9B,GAGzB,QAASe,GAAqBf,EAASK,GAC/BL,EAAQoB,SAAWW,IAEvB/B,EAAQsB,QAAUjB,EAClBL,EAAQoB,OAASC,EAEmB,IAAhCrB,EAAQgC,aAAaC,QAErBrB,EAAgBkB,EAAsB9B,IAI9C,QAASiB,GAAoBjB,EAASgB,GAC9BhB,EAAQoB,SAAWW,IACvB/B,EAAQoB,OAASG,EACjBvB,EAAQsB,QAAUN,EAElBJ,EAAgBgB,EAA+B5B,IAGnD,QAASwB,GAAuBU,EAAQC,EAAOC,EAAeC,GAC1D,GAAIC,GAAcJ,EAAOF,aACrBC,EAASK,EAAYL,MAEzBC,GAAOL,SAAW,KAElBS,EAAYL,GAAUE,EACtBG,EAAYL,EAASZ,GAA0Be,EAC/CE,EAAYL,EAASV,GAA0Bc,EAEhC,IAAXJ,GAAgBC,EAAOd,QACvBR,EAAgBkB,EAAsBI,GAI9C,QAASJ,GAAqB9B,GAC1B,GAAIsC,GAActC,EAAQgC,aACtBO,EAAUvC,EAAQoB,MAEtB,IAA2B,IAAvBkB,EAAYL,OAAhB,CAIA,IAAK,GAFDE,GAAO5C,EAAUiD,EAASxC,EAAQsB,QAE7BjC,EAAI,EAAGA,EAAIiD,EAAYL,OAAQ5C,GAAK,EACzC8C,EAAQG,EAAYjD,GACpBE,EAAW+C,EAAYjD,EAAIkD,GAEvBJ,EACAM,EAA4BF,EAASJ,EAAO5C,EAAUiD,GAEtDjD,EAASiD,EAIjBxC,GAAQgC,aAAaC,OAAS,GAGlC,QAASS,KACLC,KAAKzC,MAAQ,KAKjB,QAAS0C,GAAsBrD,EAAUiD,GACrC,IACI,MAAOjD,GAASiD,GAClB,MAAM/B,GAEJ,MADAoC,GAA6B3C,MAAQO,EAC9BoC,GAIf,QAASJ,GAA4BF,EAASvC,EAAST,EAAUiD,GAC7D,GACAnC,GAAOH,EAAO4C,EAAWC,EADrBC,EAAcrF,EAAoB4B,EAGtC,IAAIyD,GAWA,GAVA3C,EAAQuC,EAAsBrD,EAAUiD,GAEpCnC,IAAUwC,GACVE,GAAS,EACT7C,EAAQG,EAAMH,MACdG,EAAQ,MAERyC,GAAY,EAGZ9C,IAAYK,EAEZ,WADAY,GAAoBjB,EAASF,SAKjCO,GAAQmC,EACRM,GAAY,CAGZ9C,GAAQoB,SAAWW,IAEZiB,GAAeF,EACtBhC,EAAqBd,EAASK,GACvB0C,EACP9B,EAAoBjB,EAASE,GACtBqC,IAAYlB,EACnBN,EAAqBf,EAASK,GACvBkC,IAAYhB,GACnBN,EAAoBjB,EAASK,IAIrC,QAAS4C,GAA+BjD,EAASkD,GAC7C,IACIA,EAAS,SAAwB7C,GAC7BS,EAAqBd,EAASK,IAC/B,SAAuBW,GACtBC,EAAoBjB,EAASgB,KAEnC,MAAMP,GACJQ,EAAoBjB,EAASS,IAkBrC,QAAS0C,GAA0BC,EAAaC,EAAOC,EAAeC,GAClEZ,KAAKa,qBAAuBJ,EAC5BT,KAAK3C,QAAU,GAAIoD,GAAYzD,EAAmB4D,GAClDZ,KAAKc,eAAiBH,EAElBX,KAAKe,eAAeL,IACpBV,KAAKgB,OAAaN,EAClBV,KAAKV,OAAaoB,EAAMpB,OACxBU,KAAKiB,WAAaP,EAAMpB,OAExBU,KAAKkB,QAEe,IAAhBlB,KAAKV,OACLlB,EAAqB4B,KAAK3C,QAAS2C,KAAKrB,UAExCqB,KAAKV,OAASU,KAAKV,QAAU,EAC7BU,KAAKmB,aACmB,IAApBnB,KAAKiB,YACL7C,EAAqB4B,KAAK3C,QAAS2C,KAAKrB,WAIhDL,EAAoB0B,KAAK3C,QAAS2C,KAAKoB,oBAkI/C,QAASC,KACL,KAAM,IAAInE,WAAU,sFAGxB,QAASoE,KACL,KAAM,IAAIpE,WAAU,yHA6GxB,QAASqE,GAA+BhB,EAAUK,GAC9CZ,KAAKwB,IAAMC,IACXzB,KAAKzB,OAASqC,EACdZ,KAAKvB,OAAS1B,OACdiD,KAAKrB,QAAU5B,OACfiD,KAAKX,gBAEDrC,IAAsBuD,IACjBvF,EAAoBuF,IACrBc,IAGErB,eAAgBuB,IAClBD,IAGJhB,EAA+BN,KAAMO,IAznB7C,GAAImB,EAOAA,GALCC,MAAMC,QAKaD,MAAMC,QAJN,SAAU7G,GAC1B,MAA6C,mBAAtC8G,OAAOC,UAAUC,SAASlE,KAAK9C,GAM9C,IAsFIiH,GAtFAC,EAAmBP,EAenB/E,GAdeuF,KAAKC,KAAO,WAAa,OAAO,GAAID,OAAOE,WAGrCP,OAAOQ,QAAU,SAAUC,GAChD,GAAIC,UAAUjD,OAAS,EACnB,KAAM,IAAIkD,OAAM,gCAEpB,IAAiB,gBAANF,GACP,KAAM,IAAIpF,WAAU,6BAGxB,OADAhC,GAAW4G,UAAYQ,EAChB,GAAIpH,IAGG,GAEd+C,EAAkB,SAAcrB,EAAUE,GAC1CD,EAAcF,GAAeC,EAC7BC,EAAcF,EAAc,GAAKG,EACjCH,GAAe,EACK,IAAhBA,GAIAqF,KAIJS,EAA2C,mBAAX7H,QAA0BA,UAC1Dc,EAAkC+G,EAAsBC,kBAAoBD,EAAsBE,uBAGlGC,EAAgD,mBAAtBC,oBACD,mBAAlBC,gBACmB,mBAAnB3G,gBAmCPU,EAAgB,GAAI8E,OAAM,IAoB1BK,GADmB,mBAAZ5G,UAAyD,wBAA3B2G,SAASlE,KAAKzC,SAC3BD,IACjBO,EACiBH,IACjBqH,EACiB3G,IAEAO,GAI5B,IAAI4C,GAAyB,OACzBV,EAAyB,EACzBE,EAAyB,EACzBpB,EAA8B,GAAIuC,GAmKlCG,EAA+B,GAAIH,EAqGvCS,GAA0BsB,UAAUf,eAAiB,SAASL,GAC1D,MAAOuB,GAAiBvB,IAG5BF,EAA0BsB,UAAUV,iBAAmB,WACnD,MAAO,IAAIoB,OAAM,4CAGrBhC,EAA0BsB,UAAUZ,MAAQ,WACxClB,KAAKrB,QAAU,GAAIgD,OAAM3B,KAAKV,QAGlC,IAAIyD,GAAyBvC,CAE7BA,GAA0BsB,UAAUX,WAAa,WAK7C,IAAK,GAJD7B,GAAUU,KAAKV,OACfjC,EAAU2C,KAAK3C,QACfqD,EAAUV,KAAKgB,OAEVtE,EAAI,EAAGW,EAAQoB,SAAWW,GAA4BE,EAAJ5C,EAAYA,IACnEsD,KAAKgD,WAAWtC,EAAMhE,GAAIA,IAIlC8D,EAA0BsB,UAAUkB,WAAa,SAASC,EAAOvG,GAC7D,GAAIwG,GAAIlD,KAAKa,oBACT5F,GAAyBgI,GACrBA,EAAMjE,cAAgBkE,GAAKD,EAAMxE,SAAWW,GAC5C6D,EAAM/D,SAAW,KACjBc,KAAKmD,WAAWF,EAAMxE,OAAQ/B,EAAGuG,EAAMtE,UAEvCqB,KAAKoD,cAAcF,EAAEG,QAAQJ,GAAQvG,IAGzCsD,KAAKiB,aACLjB,KAAKrB,QAAQjC,GAAKsD,KAAKsD,YAAY5E,EAAwBhC,EAAGuG,KAItEzC,EAA0BsB,UAAUqB,WAAa,SAASI,EAAO7G,EAAGgB,GAChE,GAAIL,GAAU2C,KAAK3C,OAEfA,GAAQoB,SAAWW,IACnBY,KAAKiB,aAEDjB,KAAKc,gBAAkByC,IAAU3E,EACjCN,EAAoBjB,EAASK,GAE7BsC,KAAKrB,QAAQjC,GAAKsD,KAAKsD,YAAYC,EAAO7G,EAAGgB,IAI7B,IAApBsC,KAAKiB,YACL7C,EAAqBf,EAAS2C,KAAKrB,UAI3C6B,EAA0BsB,UAAUwB,YAAc,SAASC,EAAO7G,EAAGgB,GACjE,MAAOA,IAGX8C,EAA0BsB,UAAUsB,cAAgB,SAAS/F,EAASX,GAClE,GAAI8G,GAAaxD,IAEjBnB,GAAuBxB,EAASN,OAAW,SAASW,GAChD8F,EAAWL,WAAWzE,EAAwBhC,EAAGgB,IAClD,SAASW,GACRmF,EAAWL,WAAWvE,EAAuBlC,EAAG2B,KAIxD,IAAIoF,GAAyB,SAAaC,EAAS9C,GAC/C,MAAO,IAAImC,GAAuB/C,KAAM0D,GAAS,EAA4B9C,GAAOvD,SAGpFsG,EAA0B,SAAcD,EAAS9C,GAajD,QAASnB,GAAc/B,GACnBS,EAAqBd,EAASK,GAGlC,QAASgC,GAAYrB,GACjBC,EAAoBjB,EAASgB,GAhBjC,GAAIoC,GAAcT,KAEd3C,EAAU,GAAIoD,GAAYzD,EAAmB4D,EAEjD,KAAKqB,EAAiByB,GAElB,MADApF,GAAoBjB,EAAS,GAAIH,WAAU,oCACpCG,CAaX,KAAK,GAVDiC,GAASoE,EAAQpE,OAUZ5C,EAAI,EAAGW,EAAQoB,SAAWW,GAA4BE,EAAJ5C,EAAYA,IACnEmC,EAAuB4B,EAAY4C,QAAQK,EAAQhH,IAAKK,OAAW0C,EAAeC,EAGtF,OAAOrC,IAGPuG,EAA6B,SAAiBC,EAAQjD,GAEtD,GAAIH,GAAcT,IAElB,IAAI6D,GAA4B,gBAAXA,IAAuBA,EAAO7E,cAAgByB,EAC/D,MAAOoD,EAGX,IAAIxG,GAAU,GAAIoD,GAAYzD,EAAmB4D,EAEjD,OADAzC,GAAqBd,EAASwG,GACvBxG,GAGPyG,EAA4B,SAAgBzF,EAAQuC,GAEpD,GAAIH,GAAcT,KACd3C,EAAU,GAAIoD,GAAYzD,EAAmB4D,EAEjD,OADAtC,GAAoBjB,EAASgB,GACtBhB,GAGPoE,EAAiC,EAUjCsC,EAAiCxC,CA8HrCA,GAA+ByC,IAAMP,EACrClC,EAA+B0C,KAAON,EACtCpC,EAA+B8B,QAAUO,EACzCrC,EAA+B2C,OAASJ,EAExCvC,EAA+BO,WAC3B9C,YAAauC,EAoMbjE,KAAM,SAASmC,EAAeC,EAAakB,GACvC,GAAIrB,GAASS,KACTuD,EAAQhE,EAAOd,MAEnB,IAAI8E,IAAU7E,IAA2Be,GAAiB8D,IAAU3E,IAA0Bc,EAC1F,MAAOM,KAGXT,GAAOL,SAAW,IAElB,IAAIM,GAAQ,GAAIQ,MAAKhB,YAAYhC,EAAmB4D,GAChDuD,EAAS5E,EAAOZ,OAEpB,IAAI4E,EAAO,CACP,GAAI3G,GAAW2F,UAAUgB,EAAQ,EACjCtF,GAAgB,WACZ6B,EAA4ByD,EAAO/D,EAAO5C,EAAUuH,SAGxDtF,GAAuBU,EAAQC,EAAOC,EAAeC,EAGzD,OAAOF,IA+BX4E,QAAS,SAAS1E,EAAakB,GAC3B,MAAOZ,MAAK1C,KAAK,KAAMoC,EAAakB,IAI5C,IAAIyD,GAAkC,WAClC,GAAIC,EAGAA,GADkB,mBAAXC,QACCA,OACiB,mBAAX3J,SAA0BA,OAAOgB,SACvChB,OAEA4J,IAGZ,IAAIC,GACA,WAAaH,IAGb,WAAaA,GAAMzJ,SACnB,UAAYyJ,GAAMzJ,SAClB,OAASyJ,GAAMzJ,SACf,QAAUyJ,GAAMzJ,SAGf,WACG,GAAIwI,EAEJ,OADA,IAAIiB,GAAMzJ,QAAQ,SAAS6J,GAAKrB,EAAUqB,IACnC1J,EAAoBqI,KAG9BoB,KACDH,EAAMzJ,QAAUkJ,GAUxBM,MAYDxG,KAAKmC"},"dependencies":["mod/tfw.promise"]}